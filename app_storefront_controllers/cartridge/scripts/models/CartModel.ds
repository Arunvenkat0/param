'use strict';
/**
 * Module for cart related functionality.
 *
 * @module models/CartModel
 */
var Transaction = require('dw/system/Transaction');

/* API Includes */
var AbstractModel = require('./AbstractModel');
var ArrayList = require('dw/util/ArrayList');
var HashMap = require('dw/util/HashMap');
var List = require('dw/util/List');
var Money = require('dw/value/Money');
var MultiShippingLogger = dw.system.Logger.getLogger("multishipping");
var PaymentInstrument = require('dw/order/PaymentInstrument');
var PaymentMgr = require('dw/order/PaymentMgr');
var Product = require('~/cartridge/scripts/models/ProductModel');
var ProductInventoryMgr = require('dw/catalog/ProductInventoryMgr');
var PromotionMgr = require('dw/campaign/PromotionMgr');
var QuantityLineItem = require('~/cartridge/scripts/models/QuantityLineItemModel');
var ShippingMgr = require('dw/order/ShippingMgr');
var StoreMgr = require('dw/catalog/StoreMgr');
var StringUtils = require('dw/util/StringUtils');
var TransientAddress = require('~/cartridge/scripts/models/TransientAddressModel');
var UUIDUtils = require('dw/util/UUIDUtils');

/**
 * Cart helper providing enhanced cart functionality
 * @class module:models/CartModel~CartModel
 * @extends module:models/AbstractModel
 *
 * @param {dw.order.Basket} obj The basket object to enhance/wrap.
 */
var CartModel = AbstractModel.extend(
    /** @lends module:models/CartModel~CartModel.prototype */
    {
        /**
         * Triggers the cart calculation by executing the hook 'dw.ocapi.shop.basket.calculate'.
         *
         * @transactional
         */
        calculate : function () {
            dw.system.HookMgr.callHook("dw.ocapi.shop.basket.calculate", "calculate", this.object);
        },

        /**
         * Adds a product list item to the cart.
         *
         * @transactional
         * @param {dw.customer.ProductListItem} productListItem - The product list item whose associated product is to be added to the basket.
         * @param {Number} quantity - The quantity of the product.
         * @param {String} cgid - ID of the category context to be stored with the product line item.
         */
        addProductListItem : function (productListItem, quantity, cgid) {

            if (productListItem) {
			    var cart = this;
	
			    Transaction.wrap(function() {
	                var productOptionSelections = Product.get(productListItem.getProduct()).updateOptionSelection(request.httpParameterMap);
	
	                // TODO
	                var AddProductToBasketResult = new dw.system.Pipelet('AddProductToBasket').execute({
	                    Basket             : cart.object,
	                    ProductOptionModel : productOptionSelections,
	                    Quantity           : quantity,
	                    Category           : dw.catalog.CatalogMgr.getCategory(cgid),
	                    ProductListItem    : productListItem
	                });
	                if (AddProductToBasketResult.result === PIPELET_ERROR) {
	                    return;
	                }
	
	                cart.calculate();
			    });
            }
        },

        /**
         * Adds a product to the cart.
         *
         * @transactional
         * @param {String} pid - ID of the product that is to be added to the basket.
         * @param {Number} quantity - The quantity of the product.
         * @param {String} cgid - ID of the category context to be stored with the product line item.
         * @param {dw.catalog.ProductOptionModel} productOptionModel - The option model of the product that is to be added to the basket.
         */
        addProductItem : function (product, quantity, cgid, productOptionModel) {
		    var cart = this;
		    Transaction.wrap(function() {
				var i;
	            if (product) {

	                var AddProductToBasketResult = new dw.system.Pipelet('AddProductToBasket').execute({
	                    Basket             : cart.object,
	                    Product            : product,
	                    ProductOptionModel : productOptionModel,
	                    Quantity           : quantity,
	                    Category           : dw.catalog.CatalogMgr.getCategory(cgid)
	                });

	                if (AddProductToBasketResult.result === PIPELET_ERROR) {
	                    return;
	                }

	                if (product.bundle) {
	                    /**
	                     * By default, when a bundle is added to cart all its sub products gets added too, but if those products happens to be
	                     * variants then we have to manually replace the master products with the selected variants which gets passed in the
	                     * http params as childPids along with any options. Params: CurrentHttpParameterMap.childPids - comma separated list of
	                     * pids of the bundled products which are variations
	                     */
	                    if (request.httpParameterMap.childPids.stringValue) {
	                        var childPids = request.httpParameterMap.childPids.stringValue.split(',');

	                        for (i = 0; i < childPids.length; i++) {
	                            var childProduct = Product.get(childPids[i]).object;

	                            if (childProduct) {
	                                // why is this needed ?
	                                childProduct.updateOptionSelection(request.httpParameterMap);

	                                var foundLineItem = null;
	                                foundLineItem = this.getBundledProductLineItemByPID(lineItem, (childProduct.isVariant() ? childProduct.masterProduct.ID : childProduct.ID));

	                                if (foundLineItem) {
	                                    foundLineItem.replaceProduct(childProduct);
	                                }
	                            }
	                        }
	                    }
	                }

	                cart.calculate();

	            }
			});
        },

        /**
         * Validates the supplied coupon code and, if the coupon code is valid, applies them to the basket.
         * While applying the coupon code the pipelet adds a new CouponLineItem to the basket based on the supplied coupon code. The coupon code gets set at the CouponLineItem.
         * A coupon code can be invalid because of the following reasons:
         *  <ul>
         *  <li>The coupon code is already added to the basket</li>
         *  <li>A coupon code of the same coupon is already in basket. Adding a single coupon code of this coupon is sufficient to enable a promotion.
         *  Adding another coupon code of the same coupon does not make sense since the promotion is already enabled by the previously added code.</li>
         *  <li>The numbers of redemptions of this coupon code is 1 and the code as already been redeemed.</li>
         *  <li>The numbers of redemptions of this coupon code is > 1 and the maximum numbers of redemptions of this coupon code has already been reached.
         *  The calculation of the redempetions is based on the number of redemptions of this coupon code in past plus the number of redemptions of other coupon codes of the same coupon in the past.</li>
         *  <li>The maximum number of times this coupon can be redeemed per customer has already been reached.</li>
         *  <li>The maximum number of times this coupon can be redeemed by a customer within a given time period has already been reached.
         *  The calculation of the redempetions is based on the the number of redemptions of this coupon code in past plus the number of redemptions
         *  of other coupon codes of the same coupon in the past.</li>
         *  <li>The coupon code is unknown to the system</li>
         *  <li>The coupon is not enabled</li>
         *  <li>There exists no active promotion to which the coupon is assigned</li>
         *  </ul>
         * In this case, no CouponLineItem is added to the basket, the returned "Status" object contains the details of
         * why the coupon was invalid. Status: The status object representing a detailed result of the operation. The
         * status property (Status.status) will be set to 0 if the coupon was successfully applied or 1 otherwise. The
         * code property (Status.code) will be set to one of the following values:
         *  <ul>
         *  <li>"OK" = The coupon was applied to the basket.</li>
         *  <li>CouponStatusCodes.COUPON_CODE_ALREADY_IN_BASKET = Indicates that coupon code has already been added to basket.</li>
         *  <li>CouponStatusCodes.COUPON_ALREADY_IN_BASKET = Indicates that another code of the same MultiCode/System coupon has already been added to basket.</li>
         *  <li>CouponStatusCodes.COUPON_CODE_ALREADY_REDEEMED = Indicates that code of MultiCode/System coupon has already been redeemed.</li>
         *  <li>CouponStatusCodes.COUPON_CODE_UNKNOWN = Indicates that coupon not found for given coupon code or that the code itself was not found.</li>
         *  <li>CouponStatusCodes.COUPON_DISABLED = Indicates that coupon is not enabled.</li>
         *  <li>CouponStatusCodes.REDEMPTION_LIMIT_EXCEEDED = Indicates that number of redemptions per code exceeded.</li>
         *  <li>CouponStatusCodes.CUSTOMER_REDEMPTION_LIMIT_EXCEEDED = Indicates that number of redemptions per code and customer exceeded.</li>
         *  <li>CouponStatusCodes.TIMEFRAME_REDEMPTION_LIMIT_EXCEEDED = Indicates that number of redemptions per code, customer and time exceeded.</li>
         *  <li>CouponStatusCodes.NO_ACTIVE_PROMOTION = Indicates that coupon is not assigned to an active promotion.</li>
         * </ul>
         *
         * @transactional
         * @param {String} couponCode - The code of the coupon to add.
         * @returns {dw.system.Status} The "Status" object containing details of the add to cart action. See above.
         */
        addCoupon : function (couponCode) {
            if (couponCode) {

                var AddCouponToBasket2Result = new dw.system.Pipelet('AddCouponToBasket2').execute({
                    Basket     : this.object,
                    CouponCode : couponCode
                });

                this.calculate();
                return {'CouponStatus' : AddCouponToBasket2Result.Status};
            }
        },

        /**
         * Adds a bonus product to the cart associated with the specified BonusDiscountLineItem. The function creates
         * and returns a ProductLineItem, by assigning the specified Product and Quantity to the cart. The function adds
         * the new ProductLineItem to the default shipment.
         * The passed product must be one of the products associated with the BonusDiscountLineItem or the process will
         * fail. The process does NOT validate if the number of bonus products exceeds the maximum allowed by the bonus
         * discount. This is the job of application logic.
         * Function always creates a new product line item, regardless of the value of the site preference
         * 'Add Product Behavior'.
         *
         * @transactional
         * @param {dw.order.BonusDiscountLineItem} bonusDiscountLineItem - Line item representing an applied BonusChoiceDiscount in the basket. The
         * product must be in the bonus product list of this discount.
         * @param {dw.catalog.Product} product - The product that is to be added to the basket.
         * @param {dw.util.ArrayList} selectedOptions - Product option array of optionName/optionValue pairs.
         * @param {Number} quantity - The quantity of the product.
         *
         * @returns {dw.order.ProductLineItem} The newly created product line item.
         */
        addBonusProduct : function (bonusDiscountLineItem, product, selectedOptions, quantity) {
            // var productModel = Product.get(product);
            // productModel.updateOptionSelection();
            var ScriptResult = new dw.system.Pipelet('Script', {
                Transactional : false,
                OnError       : 'PIPELET_ERROR',
                ScriptFile    : 'cart/UpdateProductOptionSelections.ds'
            }).execute({
                    SelectedOptions : selectedOptions,
                    Product         : product
                });

            return this.object.createBonusProductLineItem(bonusDiscountLineItem, product, ScriptResult.ProductOptionModel, shipment);
        },

        /**
         * Removes a gift certificate line item from the basket.
         *
         * @transactional
         * @param {dw.order.GiftCertificateLineItem} giftCertificateLineItem - The gift certificate to remove from the basket.
         */
        removeGiftCertificateLineItem : function (giftCertificateLineItem) {

            // TODO - add check whether the given lineitem actually belongs to this cart object
            new dw.system.Pipelet('RemoveGiftCertificateLineItem').execute({
                GiftCertificateLineItem : giftCertificateLineItem
            });

            return;
        },

        /**
         * Deletes all the products associated with a bonus discount line item.
         *
         * @transactional
         * @param {dw.order.BonusDiscountLineItem} bonusDiscountLineItem - The bonus discount line item to remove the
         * product line items for.
         */
        removeBonusDiscountLineItemProducts : function (bonusDiscountLineItem) {
            // TODO - add check whether the given lineitem actually belongs to this cart object
            var plis = bonusDiscountLineItem.getBonusProductLineItems();

            for (var i = 0; i < plis.length; i++) {
                var pli = plis[i];
                if (pli.product) {
                    this.removeProductLineItem(pli);
                }
            }
        },

        /**
         * Returns the product line item of the cart having the given UUID.
         *
         * @param {String} lineItemUUID - The UUID of the line item.
         * @returns {dw.order.ProductLineItem} The product line item or null if not found.
         */
        getProductLineItemByUUID : function (lineItemUUID) {
            var plis = this.getProductLineItems();
            var lineItem = null;

            for (var i = 0, il = plis.length; i < il; i++) {
                var item = plis[i];
                if ((lineItemUUID && item.UUID === lineItemUUID)) {
                    lineItem = item;
                    break;
                }
            }

            return lineItem;
        },

        /**
         * Searches the bundled line items of the given bundle line item for a line item linking to a product with the
         * given ID.
         *
         * @param {dw.order.ProductLineItem} bundleLineItem - The bundle product line item which bundled items are
         * search for a line item having the given product id.
         * @param {String} pid - The product identifier to find the bundled product line item for.
         * @returns {dw.order.ProductLineItem} The product line item or null if not found.
         */
        getBundledProductLineItemByPID : function (bundleLineItem, pid) {
            // TODO - add check whether the given lineitem actually belongs to this cart object
            var plis = bundleLineItem.getBundledProductLineItems();
            var lineItem = null;

            for (var i = 0, il = plis.length; i < il; i++) {
                var item = plis[i];
                if ((pid && item.productID === pid)) {
                    lineItem = item;
                    break;
                }
            }

            return lineItem;
        },

        /**
         * Returns the bonus discount line item of the cart having the given UUID.
         *
         * @param {String} lineItemUUID - The UUID of the bonus discount line item.
         * @returns {dw.order.BonusDiscountLineItem} The bonus discount line item or null if not found.
         */
        getBonusDiscountLineItemByUUID : function (lineItemUUID) {
            var plis = this.getBonusDiscountLineItems();
            var lineItem = null;

            for (var i = 0, il = plis.length; i < il; i++) {
                var item = plis[i];
                if ((lineItemUUID && item.UUID === lineItemUUID)) {
                    lineItem = item;
                    break;
                }
            }

            return lineItem;
        },

        /**
         * This function will checks the instore qty against the store inventory in the case that the pli's qtyt has
         * been updated.
         *
         * @transactional
         */
        checkInStoreProducts : function () {
            if (dw.system.Site.getCurrent().getCustomPreferenceValue('enableStorePickUp')) {

                var allProductLineItems = this.getAllProductLineItems();
                for (var i = 0; i < allProductLineItems.length; i++) {
                    var pli = allProductLineItems[i];

                    //skip none instore pli's
                    if (pli.custom.fromStoreId) {
                        //check the qty against the inventory of the store with matching storeID,
                        //in the event that the cart is being updated with a new qty
                        var store = StoreMgr.getStore(pli.custom.fromStoreId);
                        var storeinventory = ProductInventoryMgr.getInventoryList(store.custom.inventoryListId);

                        if (storeinventory.getRecord(pli.productID).ATS.value >= pli.quantityValue) {
                            pli.custom.fromStoreId = store.ID;
                            pli.setProductInventoryList(storeinventory);

                        }
                        else {
                            //the in store line item will be reset to a regular home delivery item.
                            pli.custom.fromStoreId = '';
                            pli.setProductInventoryList(null);
                            pli.setShipment(this.getDefaultShipment());
                        }
                    }
                }
            }
        },

        /**
         * Checks to see if a new bonus discount line item has been created by providing a list of 'previous' discount
         * line items.
         *
         * @param {dw.util.Collection} previousBonusDiscountLineItems - base line collection of bonus discount line items.
         * @returns {dw.order.BonusDiscountLineItem} The newly created bonus discount line item.
         */
        getNewBonusDiscountLineItem : function (previousBonusDiscountLineItems) {
            if (previousBonusDiscountLineItems) {
                var newBonusDiscountLineItems = this.getBonusDiscountLineItems();
                newBonusDiscountLineItems.removeAll(previousBonusDiscountLineItems);

                if (!newBonusDiscountLineItems.isEmpty()) {
                    return newBonusDiscountLineItems[i];
                }
            }

            return;
        },

        /**
         * Replaces the current product of the specified product line item with the specified product.
         *
         * @transactional
         * @param {dw.order.ProductLineItem} lineItem - The product line item.
         * @param {dw.catalog.Product} product - The new product.
         * @param {Number} quantity - The quantity of the product line item after replacement.
         * @param {dw.catalog.ProductOptionModel} productOptionModel - The option model of the product that is to be added to the basket.
         */
        updateLineItem : function (lineItem, product, quantity, productOptionModel) {

            // lineItem.replaceProduct(product);
            // lineItem.setQuantityValue(quantity);
            // but how to set the option model?
            new dw.system.Pipelet('ReplaceLineItemProduct').execute({
                ProductLineItem    : lineItem,
                NewProduct         : product,
                Quantity           : quantity,
                ProductOptionModel : productOptionModel
            });

            if (product.isBundle()) {

                /**
                 * By default, when a bundle is added to cart all its sub products gets added too, but if those products happens to be
                 * variants then we have to manually replace the master products with the selected variants which gets passed in the
                 * http params as childPids along with any options. Params: CurrentHttpParameterMap.childPids - comma separated list of
                 * pids of the bundled products which are variations
                 */
                if (request.httpParameterMap.childPids.stringValue) {
                    var childPids = request.httpParameterMap.childPids.stringValue.split(',');

                    for (var i = 0; i < childPids.length; i++) {
                        var childProduct = Product.get(childPids[i]).object;

                        if (childProduct) {
                            // why is this needed ?
                            childProduct.updateOptionSelection(request.httpParameterMap);

                            var foundLineItem = null;
                            foundLineItem = this.getBundledProductLineItemByPID(lineItem, (childProduct.isVariant() ? childProduct.masterProduct.ID : childProduct.ID));

                            if (foundLineItem) {
                                foundLineItem.replaceProduct(childProduct);
                            }
                        }
                    }
                }
            }
        },

        /**
         * Implements a typical shopping cart checkout validation. Some parts of the validation script are specific to
         * the reference application logic and might not be applicable to our customer's storefront applications.
         * However, the shopping cart validation script can be customized to meet specific needs and requirements.
         *
         * The script implements the validation of the shopping cart against specific
         * conditions. This includes the following steps:
         * - validate that total price is not N/A
         * - validate that all products in the basket are still in site catalog and online
         * - validate that all coupon codes in the basket are valid
         * - validate that the taxes can be calculated for all products in the basket (if ValidateTax in put paramter is true)
         *
         * @returns {dw.system.Status} BasketStatus
         * @returns {Boolean} EnableCheckout
         */
        validateForCheckout : function () {

            var result = new dw.system.Pipelet('Script', {
                ScriptFile    : 'cart/ValidateCartForCheckout.ds',
                Transactional : false
            }).execute({
                    Basket      : this.object,
                    ValidateTax : false
                });

            return result;

        },

        /**
         * The function removes all empty shipments of the current cart.
         *
         * @transactional
         */
        removeEmptyShipments : function () {
            var that = this;
            // get the list of shipments
            var shipments = that.getShipments();

            dw.system.Transaction.wrap(function(){
                for (var i = 0; i < shipments.length; i++) {
                    var shipment = shipments[i];

                    if (!shipment.isDefault()) {
                        if (shipment.getProductLineItems().isEmpty() && shipment.getGiftCertificateLineItems().isEmpty()) {
                                that.removeShipment(shipment);
                        }
                    }
                }
            });
        },

        /**
         * Determines the physical shipments of the current cart. Physical shipments are shipments which contain at
         * least one product line item. A shipment which contains only gift certificates is not a physical shipment.
         *
         * @returns {dw.util.ArrayList} List of physical shipments.
         */
        getPhysicalShipments : function () {

            // list of physical shipments
            var physicalShipments = new ArrayList();

            // find physical shipments
            var shipments = this.getShipments();

            for (var i = 0; i < shipments.length; i++) {
                var shipment = shipments[i];
                if (!shipment.getProductLineItems().isEmpty() && shipment.custom.shipmentType !== 'instore') {
                    physicalShipments.add(shipment);
                }
            }

            return physicalShipments;
        },

        /**
         * Cleans the shipments of the current basket by putting all gift certificate line items to single, possibly
         * new shipments (one shipment per gift certificate line item).
         *
         * @transactional
         */
        updateGiftCertificateShipments : function () {

            // list of line items
            var giftCertificatesLI = new ArrayList();

            // find gift certificates in shipments which have
            // product line items and gift certificate line items merged
            var shipments = this.getShipments();

            for (var i = 0; i < shipments.length; i++) {
                var shipment = shipments[i];

                // skip shipment if no gift certificates are contained
                if (shipment.giftCertificateLineItems.size() === 0) {
                    continue;
                }

                // skip shipment if no products and just one gift certificate is contained
                if (shipment.productLineItems.size() === 0 && shipment.giftCertificateLineItems.size() === 1) {
                    continue;
                }

                // if there are gift certificates add them to the list
                if (shipment.giftCertificateLineItems.size() > 0) {
                    giftCertificatesLI.addAll(shipment.giftCertificateLineItems);
                }
            }

            // create a shipment for each gift certificate line item
            for (var i = 0; i < giftCertificatesLI.length; i++) {
                var newShipmentID = this.determineUniqueShipmentID('Shipment #');
                giftCertificatesLI[i].setShipment(this.createShipment(newShipmentID));
            }
        },

        /**
         * Determines a unique shipment ID for shipments in the current cart and the given base ID. The function appends
         * a counter to the base ID and checks the existence of the resulting ID. If the resulting ID is unique this ID
         * is returned, if not the counter is incremented and checked again.
         *
         * @param {String} baseID - The base ID.
         * @returns {String} Calculated shipment ID.
         */
        determineUniqueShipmentID : function (baseID) {
            var counter = 1;
            var shipment = null;
            var candidateID = baseID + '' + counter;

            while (shipment === null) {
                shipment = this.getShipment(candidateID);
                if (shipment) {
                    // this ID is already taken, increment the counter
                    // and try the next one
                    counter++;
                    candidateID = baseID + '' + counter;
                    shipment = null;
                }
                else {
                    return candidateID;
                }
            }

            // should never go here
            return null;
        },

        /**
         * Creates a shipping address for the shipment with the given shipment ID.
         *
         * @transactional
         * @param {String} shipmentID - The ID of the shipment to create the shipping address for.
         * @returns {dw.order.OrderAddress} The created shipping address.
         */
        createShipmentShippingAddress : function (shipmentID) {

            var shipment = this.getShipment(shipmentID);
            var shippingAddress = shipment.getShippingAddress();

            // if the shipment has no shipping address yet, create one
            if (shippingAddress === null) {
                shippingAddress = shipment.createShippingAddress();
            }

            return shippingAddress;

        },

        /**
         * This script scans the basket and consildates items that are going to the same store, it also creates shipmets
         * with shipment type and method for the rest of checkout.
         *
         * @transactional
         * @returns {boolean} Boolean used to show the shipping form fields if there is a home delivery found in the basket.
         */
        consolidateInStoreShipments : function () {

            var sliArrayList = new ArrayList();
            var homeDeliveries = false;
            var storeObject, shippingAddress, orderAddress;

            var plis = this.getAllProductLineItems();
            for (var i = 0; i < plis.length; i++) {
                var pli = plis[i];

                if (pli.custom.fromStoreId === null) {
                    //skip none instore pli's
                    homeDeliveries = true;
                    continue;
                }
                if (pli.shipment.shippingMethod && pli.shipment.shippingMethod.custom.storePickupEnabled) {
                    //check to see if the storeid has changed
                    if (pli.custom.fromStoreId === pli.shipment.custom.fromStoreId) {
                        if (pli.shipment.shippingAddress) {
                            continue;
                        }
                        else {
                            //create the shipment address to reflect the new store address
                            shippingAddress = new TransientAddress();
                            storeObject = StoreMgr.getStore(pli.custom.fromStoreId);
                            orderAddress = pli.shipment.createShippingAddress();
                            shippingAddress.storeAddressTo(orderAddress, storeObject);
                            continue;
                        }
                    }
                    else {
                        storeObject = StoreMgr.getStore(pli.custom.fromStoreId);
                        //change the shipment address to reflect the new store address
                        pli.shipment.shippingAddress.setFirstName('');
                        pli.shipment.shippingAddress.setLastName(storeObject.name);
                        pli.shipment.shippingAddress.setAddress1(storeObject.address1);
                        pli.shipment.shippingAddress.setAddress2(storeObject.address2);
                        pli.shipment.shippingAddress.setCity(storeObject.city);
                        pli.shipment.shippingAddress.setPostalCode(storeObject.postalCode);
                        pli.shipment.shippingAddress.setStateCode(storeObject.stateCode);
                        pli.shipment.shippingAddress.setCountryCode(storeObject.custom.countryCodeValue);
                        pli.shipment.shippingAddress.setPhone(storeObject.phone);
                        pli.shipment.custom.fromStoreId = pli.custom.fromStoreId;
                        continue;
                    }
                }

                //check to see if we are creating a new shipment or adding to an existing one
                if (sliArrayList.contains(pli.custom.fromStoreId)) {
                    //add the pli to the existing shipment
                    //loop through to find the shipment with the storeid and set it as the shipment for the pli
                    var shipments = this.getShipments();
                    for (var j = 0; j < this.getShipments().length; j++) {
                        var inStoreShipment = shipments[j];

                        if (inStoreShipment.custom.fromStoreId && (pli.custom.fromStoreId === inStoreShipment.custom.fromStoreId)) {
                            //have found an existing shipment that has the correct address
                            pli.setShipment(inStoreShipment);
                        }

                    }

                }
                else {
                    //create a new shipment to put this pli in
                    var shipment = null;
                    shipment = this.createShipment(UUIDUtils.createUUID());
                    shipment.custom.fromStoreId = pli.custom.fromStoreId;
                    shipment.custom.shipmentType = 'instore';

                    var inStoreShippingMethod = null;
                    //loop over the shipping methods and pick the instore one

                    var shippingMethods = new ArrayList(ShippingMgr.getShipmentShippingModel(shipment).getApplicableShippingMethods());
                    for (var k = 0; k < shippingMethods.length; k++) {
                        var shippingMethod = shippingMethods[k];

                        if (shippingMethod.custom.storePickupEnabled) {
                            shipment.setShippingMethod(shippingMethod);
                        }

                    }

                    shippingAddress = new TransientAddress();
                    storeObject = StoreMgr.getStore(pli.custom.fromStoreId);
                    orderAddress = shipment.createShippingAddress();
                    shippingAddress.storeAddressTo(orderAddress, storeObject);
                    pli.setShipment(shipment);

                }

                sliArrayList.add(pli.custom.fromStoreId);
            }

            return homeDeliveries;
        },

        /**
         * This script updates the shipping method of the given shipment. If a shipping method ID is  given, the given
         * shipping method used to update the shipment.
         *
         * @param {dw.order.ShippingMethod} shippingMethod
         * @returns {{shippingExclDiscounts: *, shippingInclDiscounts: *, productShippingCosts: Array, productShippingDiscounts: ArrayList, shippingPriceAdjustments: Array, shippingPriceAdjustmentsTotal: Money, surchargeAdjusted: Money, baseShipping: *, baseShippingAdjusted: *}}
         */
        preCalculateShipping : function (shippingMethod) {

            var shipment = this.getDefaultShipment();

            if (shipment) {
                var currencyCode = this.getCurrencyCode();
                var discountPlan             = PromotionMgr.getDiscounts(this.object),
                    productShippingCosts     = [], // array to hold product level shipping costs (fixed or surcharges), each entry is an object containing product name and shipping cost
                    productShippingDiscounts = new ArrayList(), // list holds all products shipping discounts NOT promotions e.g. fixed shipping discount or free shipping for individual products discount
                    productIter              = this.getAllProductLineItems().iterator(),
                    priceAdjArray            = [], // array to hold shipping price adjustments data (we have to create objects since price adjustments get lost after applying a shipping method
                    priceAdjIter             = shipment.getShippingPriceAdjustments().iterator(),
                    priceAdjTotal            = new Money(0.0, currencyCode), // total of all price adjustments
                    surchargeTotal           = new Money(0.0, currencyCode), // total of all surcharges
                    adustedSurchargeTotal    = new Money(0.0, currencyCode); // total of all surcharges minus price adjustments

                // iterate over all products in the basket
                // and calculate their shipping cost and shipping discounts
                while (productIter.hasNext()) {
                    var pli = productIter.next();
                    var product = pli.product;
                    if (product) {
                        var psc = ShippingMgr.getProductShippingModel(product).getShippingCost(shippingMethod);
                        productShippingCosts[productShippingCosts.length] = {
                            'name'         : product.name,
                            'shippingCost' : psc,
                            'qty'          : pli.getQuantity()
                        };
                        if (psc && psc.getAmount() && psc.isSurcharge()) {
                            // update the surcharge totals
                            surchargeTotal = surchargeTotal.add(psc.getAmount());
                            adustedSurchargeTotal = adustedSurchargeTotal.add(psc.getAmount());
                        }
                        //productShippingDiscounts.addAll(discountPlan.getProductShippingDiscounts(pli));
                        //productShippingDiscounts.addAll(pli.shippingLineItem.priceAdjustments);
                        if (pli.shippingLineItem) {
                            var pdiscountsiter = pli.shippingLineItem.priceAdjustments.iterator();
                            while (pdiscountsiter.hasNext()) {
                                var priceAdj = pdiscountsiter.next();
                                if (priceAdj && priceAdj.promotion !== null) {
                                    if (pli.shippingLineItem.isSurcharge()) {
                                        // adjust the surchage total value
                                        adustedSurchargeTotal = adustedSurchargeTotal.add(priceAdj.price);
                                    }
                                    productShippingDiscounts.add({
                                        "price"      : priceAdj.price,
                                        "calloutMsg" : priceAdj.promotion.calloutMsg
                                    });
                                }
                            }
                        }
                    }
                }

                // iterate over all shipping price adjustments and
                // grab price and calloutMsg objects
                while (priceAdjIter.hasNext()) {
                    var priceAdj = priceAdjIter.next();
                    if (priceAdj && priceAdj.promotion !== null) {
                        priceAdjTotal = priceAdjTotal.add(priceAdj.price);
                        priceAdjArray[priceAdjArray.length] = {
                            "price"      : priceAdj.price,
                            "calloutMsg" : priceAdj.promotion.calloutMsg
                        };
                    }
                }

                var baseShipping = this.getShippingTotalPrice().subtract(surchargeTotal);
                var baseShippingAdjusted = null;
                if (priceAdjTotal >= 0) {
                    baseShippingAdjusted = baseShipping.subtract(priceAdjTotal);
                }
                else {
                    baseShippingAdjusted = baseShipping.add(priceAdjTotal);
                }

                return {
                    "shippingExclDiscounts"         : this.getShippingTotalPrice(),
                    "shippingInclDiscounts"         : this.getAdjustedShippingTotalPrice(),
                    "productShippingCosts"          : productShippingCosts,
                    "productShippingDiscounts"      : productShippingDiscounts,
                    "shippingPriceAdjustments"      : priceAdjArray,
                    "shippingPriceAdjustmentsTotal" : priceAdjTotal,
                    "surchargeAdjusted"             : adustedSurchargeTotal,
                    "baseShipping"                  : baseShipping,
                    "baseShippingAdjusted"          : baseShippingAdjusted
                };
            }
        },

        /**
         * This script sets the shipping method of the given shipment to the passed method.  The list of allowed shipping
         * methods may be passed in as a parameter.  If not, then it is retrieved using ShipmentShippingModel.getApplicableShippingMetods().
         * If the passed shipping method is not in this list, then the script uses the default shipping method.
         * If the default shipping method is not in the list, the script uses the first method in the list.
         *
         * @transactional
         * @param {String} shipmentID - The ID of the shipment to update the shipping method for.
         * @param {String} shippingMethodID - The ID of the shipping method to set for the shipment.
         * @param {dw.order.ShippingMethod} shippingMethod - The shipping method to set for the shipment.
         * @param {dw.util.Collection} shippingMethods - The list of applicable shipping methods.
         */
        updateShipmentShippingMethod : function (shipmentID, shippingMethodID, shippingMethod, shippingMethods) {

            var shipment = this.getShipment(shipmentID);

            if (!shippingMethods) {
                shippingMethods = ShippingMgr.getShipmentShippingModel(shipment).getApplicableShippingMethods();
            }

            // 1) Try to set the shipment shipping method to the passed one.
            for (var i = 0; i < shippingMethods.length; i++) {
                var method = shippingMethods[i];

                if (!shippingMethod) {
                    if (!method.ID.equals(shippingMethodID)) {
                        continue;
                    }
                }
                else {
                    if (method !== shippingMethod) {
                        continue;
                    }

                }

                // set this shipping method
                shipment.setShippingMethod(method);
                return;
            }

            var defaultShippingMethod = ShippingMgr.getDefaultShippingMethod();
            if (shippingMethods.contains(defaultShippingMethod)) {
                // 2) Set the default shipping method if it is applicable.
                shipment.setShippingMethod(defaultShippingMethod);
            }
            else if (shippingMethods.length > 0) {
                // 3) Set the first shipping method in the applicable list.
                shipment.setShippingMethod(shippingMethods.iterator().next());
            }
            else {
                // 4) Invalidate the current shipping method selection.
                shipment.setShippingMethod(null);
            }

            return;
        },

        /**
         * Retrieves the list of applicable shipping methods for a given shipment and a full or partial shipping address.
         * A shipping method is applicable if it does not exclude any of the products in the shipment, and does not
         * exclude the specified address.
         *
         * @param {module:models/TransientAddressModel~TransientAddressModel} address - The address to get the applicable shipping
         * methods for.
         * @returns {dw.util.Collection} The list of applicable shipping methods for the default shipment and the given address.
         */
        getApplicableShippingMethods : function (address) {
            // Modify as needed.
            if (!address.countryCode) {
                address.countryCode = "US";
            }
            if (!address.stateCode) {
                address.stateCode = "NY";
            }

            // Retrieve the list of applicable shipping methods for the given shipment and address.
            return ShippingMgr.getShipmentShippingModel(this.getDefaultShipment()).getApplicableShippingMethods(address);
        },

        /**
         * Calculates the amount to be payed by a non-gift certificate payment instrument based on the given basket.
         * The method subtracts the amount of all redeemed gift certificates from the order total and returns this
         * value.
         *
         * @returns {dw.value.Money} The amount to be payed by a non-giftcertificate payment instrument.
         */
        getNonGiftCertificateAmount : function () {
            // the total redemption amount of all gift certificate payment instruments in the basket
            var giftCertTotal = new Money(0.0, this.getCurrencyCode());

            // get the list of all gift certificate payment instruments
            var gcPaymentInstrs = this.getGiftCertificatePaymentInstruments();
            var iter = gcPaymentInstrs.iterator();
            var orderPI = null;

            // sum the total redemption amount
            while (iter.hasNext()) {
                orderPI = iter.next();
                giftCertTotal = giftCertTotal.add(orderPI.getPaymentTransaction().getAmount());
            }

            // get the order total
            var orderTotal = this.getTotalGrossPrice();

            // calculate the amount to charge for the payment instrument
            // this is the remaining open order total which has to be paid
            var amountOpen = orderTotal.subtract(giftCertTotal);

            // return the open amount
            return amountOpen;
        },

        /**
         * Removes a gift certificate payment instrument with the given gift certificate ID
         * from the basket.
         *
         * @transactional
         * @param {String} giftCertificateID - The ID of the gif certificate to remove the payment instrument for.
         */
        removeGiftCertificatePaymentInstrument : function (giftCertificateID) {

            // iterate over the list of payment instruments
            var gcPaymentInstrs = this.getGiftCertificatePaymentInstruments(giftCertificateID);
            var iter = gcPaymentInstrs.iterator();
            var existingPI = null;

            // remove (possible multiple) gift certificate payment
            // instruments for this gift certificate ID
            while (iter.hasNext()) {
                existingPI = iter.next();
                this.removePaymentInstrument(existingPI);
            }

            return;
        },

        /**
         * Deletes multiple payment instruments.
         *
         * @transactional
         * @param {dw.util.Collection} paymentInstruments The payment instruments to remove.
         */
        removePaymentInstruments : function (paymentInstruments) {

            for (var i = 0; i < paymentInstruments.length; i++) {
                var pi = paymentInstruments[i];
                this.removePaymentInstrument(pi);
            }

        },

        /**
         * This script calculates the total amount of an order that will be paid for by gift certificate payment
         * instruments. The remaining open amount (if there is any) will be applied to the non-gift certificate payment
         * instrument (such as a credit card). Note, that this script assumes that only one non-gift certificate
         * payment instrument is used for the payment.
         *
         * @returns {boolean} false in the case of an error, true otherwise.
         */
        calculatePaymentTransactionTotal : function () {

            // get all payment instruments for the basket
            var iter = this.getPaymentInstruments().iterator();
            var paymentInstrument = null;
            var nonGCPaymentInstrument = null;
            var giftCertTotal = new Money(0.0, this.getCurrencyCode());

            // locate any non-gift certificate payment instrument
            while (iter.hasNext()) {
                paymentInstrument = iter.next();
                if (PaymentInstrument.METHOD_GIFT_CERTIFICATE.equals(paymentInstrument.getPaymentMethod())) {
                    giftCertTotal = giftCertTotal.add(paymentInstrument.getPaymentTransaction().getAmount());
                    continue;
                }

                // we captured the non-gift certificate payment instrument
                nonGCPaymentInstrument = paymentInstrument;
                break;
            }

            // get the order total
            var orderTotal = this.getTotalGrossPrice();

            // if we found gift certificate payment and non-gift certificate payment
            // instrument we are done
            if (!nonGCPaymentInstrument) {
                // if we have no other payment types and the gift certificate
                // doesn't cover the order we need to error out.
                if (giftCertTotal < orderTotal) {
                    return false;
                }
                else {
                    return true;
                }
            }

            // calculate the amount to be charged for the
            // non-gift certificate payment instrument
            var amount = this.getNonGiftCertificateAmount();

            // now set the non-gift certificate payment instrument total.
            if (amount.value <= 0.0) {
                var zero = new Money(0, amount.getCurrencyCode());
                nonGCPaymentInstrument.getPaymentTransaction().setAmount(zero);
            }
            else {
                nonGCPaymentInstrument.getPaymentTransaction().setAmount(amount);
            }

            return true;
        },

        /**
         * Creates a list of gift certificate ids from gift certificate payment instruments.
         *
         * @returns {dw.util.ArrayList} The list of gift certificate IDs.
         */
        getGiftCertIdList : function () {
            var gcIdList = new ArrayList();
            var gcPIIter = this.getGiftCertificatePaymentInstruments.iterator();

            while (gcPIIter.hasNext()) {
                gcIdList.add((gcPIIter.next()).getGiftCertificateCode());
            }

            return gcIdList;
        },

        /**
         * This script creates new ProductLineItems and Shipments from the List of the address selections with help of
         * a data structure (address and product relations through HashMaps).
         *
         * @transactional
         * @param {dw.web.FormList} quantityLineItems
         * @returns {boolean} false in the case of an error, true otherwise.
         */
        mergeQuantities : function (quantityLineItems) {

            var addressRelations = new HashMap();
            var defaultShippingSet = false;

            /**
             * Build new data structure through HashMaps from address-products-relations (stored in FormList)
             * to build the new ProductLineItems in dependency to their addresses and quantities
             *
             * address relation:    +===============+=================+
             *                      |    Key        |    Value        |
             *                      +===============+=================+
             *                      |    address1   |    products1  --|------->    product relation 1:    +===============+===============+
             *                      +---------------+-----------------+                                   |    Key        |    Value      |
             *                      |    address2   |    products2  --|--->    product relation 2         +===============+===============+
             *                      +---------------+-----------------+                                   |   productID1  |   quantity1   |
             *                      |    ...        |    ...          |                                   +---------------+---------------+
             *                                                                                            |   productID2  |   quantity2   |
             *                                                                                            +---------------+---------------+
             *                                                                                            |    ...        |    ...        |
             */

            for (var i = 0; i < quantityLineItems.getChildCount(); i++) {
                var qli = quantityLineItems[i];
                var selectedAddress = qli.addressList.selectedOptionObject;
                var productID = qli.object.productID;

                var productOptionID = qli.object.optionID;
                productID = productID + '.' + productOptionID;

                if (selectedAddress === null) {
                    return false;
                }

                if (addressRelations.containsKey(selectedAddress)) {
                    var productRelations = addressRelations.get(selectedAddress);
                    if (productRelations.containsKey(productID)) {
                        var quantity = productRelations.get(productID);
                        productRelations.put(productID, quantity + 1);
                    }
                    else {
                        productRelations.put(productID, 1);
                    }
                }
                else {
                    var productRelations = new HashMap();
                    productRelations.put(productID, 1);
                    addressRelations.put(selectedAddress, productRelations);
                }
            }

            //Remove all ProductLineItems and Shipments to create new ones
            var plis = this.getProductLineItems();
            for (var i = 0; i < plis.length; i++) {
                var pli = plis[i];
                if (empty(pli.custom.fromStoreId)) {
                    this.removeProductLineItem(pli);
                }
            }

            var shipments = this.getShipments();
            for (var i = 0; i < shipments.length; i++) {
                var shipment = shipments[i];
                //if the shipment is for a gift certificate or the default shipment, it will not be removed from the cart
                if (!shipment.isDefault() && !(shipment.giftCertificateLineItems.length > 0) && shipment.custom.shipmentType !== 'instore') {
                    this.removeShipment(shipment);
                }
            }

            // Build new ProductLineItems and Shipments with the new created data structure
            var addresses = addressRelations.keySet();

            for (var i = 0; i < addresses.length; i++) {
                var address = addresses[i];
                var shipment = null;
                var orderAddress = null;
                if (!defaultShippingSet) {
                    shipment = this.getDefaultShipment();
                    defaultShippingSet = true;
                }
                else {
                    shipment = this.createShipment(address.UUID);
                }
                orderAddress = shipment.createShippingAddress();

                var shippingAddress = new TransientAddress();
                shippingAddress.UUID = UUIDUtils.createUUID();
                shippingAddress.copyFrom(address);
                shippingAddress.copyTo(orderAddress);

                var productRelations = addressRelations.get(address);
                var products = productRelations.keySet();

                var product_ID = '';
                var optionID = '';

                for (var j = 0; j < products.length; j++) {
                    var product = products[j];
                    var splitarray = product.split('.');
                    product_ID = splitarray[0];
                    optionID = splitarray[1];

                    var pli = this.createProductLineItem(product_ID, shipment);
                    pli.setQuantityValue(productRelations.get(product));

                    //re-assign the option product based on the optionID
                    if (optionID !== 'na') {
                        var productOptionModel = pli.product.getOptionModel();
                        var productOptions = productOptionModel.getOptions();
                        var pliOptionArrayList = new ArrayList(productOptions);
                        var productOption = pliOptionArrayList[0];

                        var options = productOptionModel.getOptionValues(productOption).iterator();
                        while (options.hasNext()) {

                            var optionValue = options.next();

                            // if the option id equals the selection option id, set the selected option
                            if (optionValue.getID() === optionID) {

                                var pliOptionProducts = new ArrayList(pli.optionProductLineItems);

                                for (var k = 0; k < pliOptionProducts.length; k++) {
                                    pliOptionProducts[k].updateOptionValue(optionValue);
                                }
                            }
                        }
                    }
                }
            }

            return true;
        },

        /**
         * Verifies whether existing non-gift-certificate payment instrument method / cards are still applicable on
         * base of the given attributes. Returns the collection of valid and invalid payment instruments.
         *
         * @param {dw.customer.Customer} customer - The current customer.
         * @param {String} countryCode - The country code.
         * @param {Number} amount - The payment amount.
         *
         * @returns {dw.util.Collection} ValidPaymentInstruments - The collection of valid payment instruments.
         * @returns {dw.util.Collection} InvalidPaymentInstruments - The collection of invalid payment instruments.
         */
        validatePaymentInstruments : function (customer, countryCode, amount) {

            var paymentInstruments = this.getPaymentInstruments();

            // get applicable payment methods
            var methods = PaymentMgr.getApplicablePaymentMethods(customer, countryCode, amount);

            // get applicable payment cards from CREDIT_CARD payment method
            var ccMethod = PaymentMgr.getPaymentMethod(PaymentInstrument.METHOD_CREDIT_CARD);
            var cards = ccMethod ? ccMethod.getApplicablePaymentCards(customer, countryCode, amount) : List.EMPTY_LIST;

            // collects all not applicable payment instruments
            var validPaymentInstruments = new ArrayList(paymentInstruments);
            var invalidPaymentInstruments = new ArrayList();

            // get payment instruments from basket

            for (var i = 0; i < paymentInstruments.length; i++) {
                var pi = paymentInstruments[i];
                // ignore gift certificate payment instruments
                if (PaymentInstrument.METHOD_GIFT_CERTIFICATE.equals(pi.paymentMethod)) {
                    continue;
                }

                // get payment method
                var method = PaymentMgr.getPaymentMethod(pi.getPaymentMethod());

                // check, whether payment method is still applicable
                if (method && methods.contains(method)) {
                    // in case of method CREDIT_CARD, check payment cards
                    if (PaymentInstrument.METHOD_CREDIT_CARD.equals(pi.paymentMethod)) {
                        // get payment card
                        var card = PaymentMgr.getPaymentCard(pi.creditCardType);

                        // check, whether payment card is still applicable
                        if (card && cards.contains(card)) {
                            continue;
                        }
                    }
                    else {
                        // continue, if method is applicable
                        continue;
                    }
                }

                // collect invalid payment instruments
                invalidPaymentInstruments.add(pi);
                validPaymentInstruments.remove(pi);
            }

            if (!invalidPaymentInstruments.empty) {
                return {
                    InvalidPaymentInstruments : invalidPaymentInstruments,
                    ValidPaymentInstruments   : validPaymentInstruments
                };
            }
            else {
                return {
                    ValidPaymentInstruments : validPaymentInstruments
                };
            }
        },

        /**
         * Creates a gift certificate payment instrument from the given gift certificate ID for the given basket. The
         * script attempts to redeem the current balance of the gift certificate. If the current balance exceeds the
         * order total, this amount is redeemed and the balance is lowered.
         *
         * @transactional
         * @param {dw.order.GiftCertificate} giftCertificate - The Gift Certificate.
         * @returns {dw.order.PaymentInstrument} The created PaymentInstrument.
         */
        createGiftCertificatePaymentInstrument : function (giftCertificate) {

            // remove any duplicates
            // iterate over the list of payment instruments to check
            // if the gift certificate is already being used as payment instrument
            var gcPaymentInstrs = this.getGiftCertificatePaymentInstruments(giftCertificate.getGiftCertificateCode()).iterator();
            var existingPI = null;

            // remove found gift certificates, since we don't want duplicates
            while (gcPaymentInstrs.hasNext()) {
                existingPI = gcPaymentInstrs.next();
                this.removePaymentInstrument(existingPI);
            }

            // fetch the balance and the order total
            var balance = giftCertificate.getBalance();
            var orderTotal = this.getTotalGrossPrice();

            // assume to redeem the remaining balance
            var amountToRedeem = balance;

            // because there may be multiple gift certificates, we adjust the amount being applied to the current
            // gift certificate based on the order total minus the aggregate amount of the current gift certificates.
            // the total redemption amount of all gift certificates for the basket
            var giftCertTotal = new Money(0.0, this.getCurrencyCode());

            // iterate over the list of gift certificate payment instruments
            // and update the total redemption amount
            var gcPaymentInstrs = this.getGiftCertificatePaymentInstruments().iterator();
            var orderPI = null;

            while (gcPaymentInstrs.hasNext()) {
                orderPI = gcPaymentInstrs.next();
                giftCertTotal = giftCertTotal.add(orderPI.getPaymentTransaction().getAmount());
            }

            // calculate the remaining order balance
            // this is the remaining open order total which has to be paid
            var orderBalance = orderTotal.subtract(giftCertTotal);

            // the redemption amount exceeds the order balance
            // use the order balance as maximum redemption amount
            if (orderBalance < amountToRedeem) {
                // use the remaining order balance
                amountToRedeem = orderBalance;
            }

            // create a payment instrument from this gift certificate
            return this.object.createGiftCertificatePaymentInstrument(giftCertificate.getGiftCertificateCode(), amountToRedeem);
        },

        /**
         * Creates for each quantity of a ProductLineItem a new    QuantityLineItem helper object, where the important data
         * is stored at.
         *
         * @param {dw.order.ProductLineItem} pli - The ProductLineItem.
         * @param {dw.util.ArrayList} quantityLineItems - The incoming/existing QuantityLineItems.
         * @returns {dw.util.ArrayList} The sparated QuantityLineItems.
         */
        separateQuantities : function (pli, quantityLineItems) {

            var quantity = pli.quantityValue;

            // Create new ArrayList if there are no QLIs
            if (!quantityLineItems) {
                quantityLineItems = new ArrayList();
            }

            // Create for each quantity of the ProductLineItem a new QuantityLineItem
            for (var i = 0; i < quantity; i++) {
                //skipping plis that are using the instore pick up shipping method
                if (empty(pli.custom.fromStoreId)) {
                    quantityLineItems.add(new QuantityLineItem(pli));
                }
            }

            return quantityLineItems;
        },

        /**
         * Loads customer addresses and shipment addresses and stores them into the session address book attribute of the cart, if it is available and configured in BM.
         * @transactional
         *
         * @param {dw.customer.Customer} customer - The customer to load the addresses from.
         */
        initAddressBook : function (customer) {

            var shipments = this.getShipments();

            // Load addresses from Customer Address Book
            if (customer.registered && customer.addressBook) {
                for (var i = 0; i < customer.addressBook.addresses.length; i++) {
                    this.addAddressToAddressBook(customer.addressBook.addresses[i]);
                }
            }

            // Load addresses from Shipments excluding instore shipments
            if (shipments) {
                for (var i = 0; i < shipments.length; i++) {
                    var shipment = shipments[i];
                    if (shipment.shippingAddress && shipment.custom.shipmentType !== 'instore') {
                        this.addAddressToAddressBook(shipment.getShippingAddress());
                    }
                }
            }
        },

        /**
         * Returns all addresses of the carts address book. The addresses are stored as a JSON object in a custom
         * attribute names 'sessionAddressBook'.
         *
         * @returns {dw.util.ArrayList} An ArrayList containing a addresses of the addresses stored in the carts address
         * book.
         */
        getAddressBookAddresses : function () {
            var addressBook = new Object();
            var addresses = new ArrayList();

            if (!empty(this.object.describe().getCustomAttributeDefinition('sessionAddressBook'))) {

                // Session addresses availability check
                if (this.object.custom.sessionAddressBook) {
                    try {
                        addressBook = JSON.parse(this.object.custom.sessionAddressBook);
                        addresses.add(addressBook.addresses);
                    } catch (error) {
                        MultiShippingLogger.error(Resource.msgf("multishipping.error.parsejson", "checkout", null, error));
                        return null;
                    }
                }

                return addresses;
            }

            return null;
        },

        /**
         * Adds the given address to the address book of the cart.
         *
         * @transactional
         * @param {module:models/TransientAddressModel~TransientAddressModel} addressToAdd - The address to add.
         */
        addAddressToAddressBook : function (addressToAdd) {
            var address = new TransientAddress();
            var addressBook = new Object();

            if (addressToAdd) {

                // Try to parse incoming JSON string
                if (this.object.custom.sessionAddressBook) {
                    try {
                        addressBook = JSON.parse(this.object.custom.sessionAddressBook);
                    } catch (error) {
                        MultiShippingLogger.error(Resource.msgf("multishipping.error.parsejson", "checkout", null, error));
                        return;
                    }
                }

                // Check if JSON object already has addresses
                if (!(addressBook.addresses instanceof Array)) {
                    addressBook.addresses = new Array();
                }

                // Copy referenceAddress to address object to be stringified
                address.copyFrom(addressToAdd);
                address.UUID = addressToAdd.UUID;
                // Add address if not already existing
                if (!address.addressExists(addressBook.addresses)) {
                    addressBook.addresses.push(address);
                }
            }

            this.object.custom.sessionAddressBook = JSON.stringify(addressBook);
        },

        /**
         * Updates the given address in the carts address book.
         *
         * @transactional
         * @param {module:models/TransientAddressModel~TransientAddressModel} addressToUpdate - The address to update.
         */
        updateAddressBookAddress : function (addressToUpdate) {
            var addresses = new Array();
            var addressBook = new Object();

            if (addressToUpdate && this.object.custom.sessionAddressBook) {
                try {
                    addressBook = JSON.parse(this.object.custom.sessionAddressBook);
                } catch (error) {
                    MultiShippingLogger.error(Resource.msgf("multishipping.error.parsejson", "checkout", null, error));
                    return;
                }

                addresses = addressBook.addresses;

                for (var i = 0; i < addresses.length; i++) {
                    if (addresses[i].UUID === addressToUpdate.UUID) {
                        addressToUpdate.ID = addresses[i].ID;
                        addressToUpdate.referenceAddressUUID = addresses[i].referenceAddressUUID;
                        addressBook.addresses[i] = addressToUpdate;
                    }
                }

                this.object.custom.sessionAddressBook = JSON.stringify(addressBook);
            }
        },

        /**
         * Creates an Order based on the cart. If the order could be created successfully, it will be in status CREATED.
         * The cart will be removed from the session and marked for removal.
         *
         * If the order could not be created the function returns null, if any of the following conditions are encountered:
         * <ul>
         * <li>any of the totals (net, gross, tax) of the basket is N/A</li>
         * <li>any of the product items is not available</li>
         * <li>any campaign-based coupon in the basket is invalid (see dw.order.CouponLineItem.isValid())</li>
         * <li>the basket represents an order being edited, but the order has been already been replaced by another order</li>
         * <li>the basket represents an order being edited, but the customer associated with the original order is not the same as the current customer</li>
         * </ul>
         * All empty shipments of the basket are removed before creating the order. A shipment is empty if it contains
         * no product or gift certificate line items all total prices (net, gross, tax) are 0.0.
         *
         * The function decrements inventory for all products contained in the order. (Means the 'reserve inventory for
         * order' functionality must not be sub-sequently called.) The function redeems all coupons contained in the order.
         *
         * If the cart contains product or gift certificate line items associated with product list items, the function
         * updates the purchase the product list items. For example, if the basket contains an item added from a gift
         * registry, the purchase history of the respective gift registry item is updated.
         *
         * @transactional
         * @returns {dw.order.Order} The created order in status CREATED or null if an error occured.
         */
        createOrder : function () {
            var CreateOrder2Result = new dw.system.Pipelet('CreateOrder2', {
                CreateCustomerNo : true
            }).execute({
                    Basket : this.object
                });
            if (CreateOrder2Result.result === PIPELET_ERROR) {
                return null;
            }
            else {
                return CreateOrder2Result.Order;
            }
        },

        /**
         * Determines if the cart already contains payment instruments of the given payment method and removes them
         * from the basket.
         *
         * @transactional
         * @param {String} method - Name of the payment method
         */
        removeExistingPaymentInstruments : function (method) {
            var iter = this.getPaymentInstruments(method).iterator();

            // remove them
            while (iter.hasNext()) {
                this.removePaymentInstrument(iter.next());
            }
        },

        getGiftCertificateLineItemByUUID : function(uuid){
            if(!this.object){
                return null;
            }
            for (var it = this.object.getGiftCertificateLineItems().iterator(); it.hasNext(); ) {
                var item = it.next();
                if (item.getUUID() === uuid) {
                    return item;
                }
            }
            return null;
        }

    });

/**
 * Use this method to get a new instance for the current or a given basket.
 *
 * @param parameter {dw.order.Basket=} The basket object to enhance/wrap. If NULL the basket is retrieved from
 * the current session, if existing.
 * @returns {module:models/CartModel~CartModel}
 */
CartModel.get = function (parameter) {
    var obj = null;

    if (!parameter) {
        var GetBasketResult = new dw.system.Pipelet('GetBasket', {
            Create : false
        }).execute();
        if (GetBasketResult.result !== PIPELET_ERROR) {
            obj = GetBasketResult.Basket;
        }
    }
    else if (typeof parameter === 'object') {
        obj = parameter;
    }
    return (obj !== null) ? new CartModel(obj) : null;
};

/**
 * Use this method to get or create a new instance of a basket.
 *
 * @returns {module:models/CartModel~CartModel}
 */
CartModel.goc = function () {
    var obj = null;

    var GetBasketResult = new dw.system.Pipelet('GetBasket', {
        Create : true
    }).execute();

    if (GetBasketResult.result !== PIPELET_ERROR) {
        obj = GetBasketResult.Basket;
    }

    return new CartModel(obj);
};

/** The cart class */
module.exports = CartModel;