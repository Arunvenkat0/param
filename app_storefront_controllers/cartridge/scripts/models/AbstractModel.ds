'use strict';

/**
 * @module models/AbstractModel
 */

/* API Includes */
var Class = require('~/cartridge/scripts/util/Class').Class;

/**
 * Abstract class for all modules following the <strong>Global Helper Concept</strong>.
 *
 * @class module:models/AbstractModel~AbstractModel
 * @extends module:util/Class
 *
 * @see https://bitbucket.org/demandware/sitegenesis-community/wiki/Home
 */
var AbstractModel = Class.extend(
    /** @lends module:models/AbstractModel~AbstractModel.prototype */
    {
        /**
         * Property holding the wrapped object which is initialized in the child classes. Usually
         * the this.get() method is used to obtain a record
         */
        object : null,

        /**
         * AbstractModel constructor
         * @constructs module:models/AbstractModel~AbstractModel
         * @param obj {Object}
         */
        init : function (obj) {
            this.object = obj;
            return this;
        },

        /**
         * Returns a wrapped object instance. This method needs to be implemented by the sub classes
         *
         * @abstract
         * @return {Void}
         */
        get : function () {
            dw.system.Logger.warn('Generic helper access method "get()" not implemented for subclass');
            return new AbstractModel({custom : {}});
        },

        /**
         * Get value from prepopulated object.
         * If the key is point-delimited trying to parse JSON
         * If not - trying to obtain a value from "custom" property of an object
         * @return {Object}
         */
        getValue : function (key) {
            if (empty(key) || !this.object) {
                return null;
            }

            // add any special value handling here (i.e. automatic handling of JSON)
            var value = this.object.custom[key];

            return value;
        },

        /**
         * Set value to prepopulated object.
         * If the key is point-delimited trying to parse JSON and set up a target value
         * @return {Boolean}
         */
        setValue : function (key, value) {
            // this will works under transactional nodes
            if (!this.object || empty(key)) {
                return false;
            }

            try {
                this.object.custom[key] = value;
            } catch (e) {
                return false;
            }
        },

        initProperties : function() {
            var instance = this;
            // properties.forEach(function(property) {
            //     instance.__defineGetter__(
            //         property,
            //         function(){
            //           return instance.object[property];
            //         }
            //     );
            // });
            var duration = new Date().getTime();
            var properties = [];
            for(var property in instance.object){
                properties.push(property);
            }
            properties.forEach(function(property) {
                if(property.indexOf('get') === 0){
                    // remove get and lowercase first character, i.e. getOnline -> online
                    var propertyName = property.substring(3,4).toLowerCase() + property.substring(4);
                    // only define if there is a corresponding property as well
                    if(properties.indexOf(propertyName) > -1){
                        //dw.system.Logger.debug('Defining property get access for {0}',propertyName);
                        instance.__defineGetter__(
                            propertyName,
                            (property in instance)?function(){return instance[property]}:function(){return instance.object[propertyName];}
                        );
                    }
                }
                // handle setters
                // if(property.indexOf('set') === 0){
                //     // remove get and lowercase first character, i.e. getOnline -> online
                //     propertyName = property.substring(3,4).toLowerCase() + property.substring(4);
                //     // only define if there is a corresponding property as well
                //     if(properties.indexOf(propertyName) > -1){
                //         dw.system.Logger.debug('Defining property set access for {0}',propertyName);
                //         instance.__defineSetter__(
                //             propertyName,
                //             (property in instance)?instance[property]:function(v){return instance.object[propertyName].call(instance.object, v);}
                //         );
                //     }
                // }
            });
            duration = new Date().getTime() - duration;
            dw.system.Logger.info('{0}ms to define properties',duration);
        },

        /**
         * Fallback to use wrapped object's native functions in case method is not defined.
         * The logic will try to invoke method for this.object, and throw TypeError if the method does not exist
         *
         * @param {String} methodName
         * @param {Array} methodArgs
         *
         * @return {*} Record function result (or exception if function not exists)
         *
         * @throws {TypeError}
         */
        __noSuchMethod__ : function (methodName, methodArgs) {
            if (methodName in this.object && 'function' === typeof this.object[methodName]) {
                return this.object[methodName].apply(this.object, methodArgs);
            }
            // If we get here, the method hasn't been found
            dw.system.Logger.error('Method "{0}" does not exist for {1}',methodName,this.object.class);
            throw new TypeError();
        }
    });

/** The AbstractModel class */
module.exports = AbstractModel;
