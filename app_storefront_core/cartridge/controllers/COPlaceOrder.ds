'use strict';

/**
 * This pipeline is responsible to create an order from the current basket. It's a pure processing pipeline and does no page
 * rendering. The pipeline is used by the checkout and is called upon the triggered place order action.
 * It contains the actual logic to authorize the payment and create the order. The pipeline communicates the result
 * of the order creation process by named end nodes and uses a status object PlaceOrderError to set proper error states.
 * The calling pipeline is responsible to react on these end nodes and to evaluate the error status.
 *
 * @module controller/COPlaceOrder
 */

/* API Includes */
var Cart = require('~/cartridge/scripts/model/Cart');
var Mail = require('dw/net/Mail');
var OrderMgr = require('dw/order/OrderMgr');
var PaymentMgr = require('dw/order/PaymentMgr');
var Template = require('dw/util/Template');
var Transaction = require('dw/system/Transaction');

/* Script Modules */
var guard = require('~/cartridge/scripts/guard');

/**
 * Responsible for payment handling. This pipeline calls the specific
 * authorization pipelines for each individual payment type. It ends on an named
 * "error" end node if either any of the authorizations failed or a payment
 * instrument is of an unknown payment method. If a payment method has no
 * payment processor assigned, the payment is deemed as authorized.
 */
function handlePayments(order) {

    if (order.getTotalNetPrice() != 0.00) {
        return {};
    }

	var paymentInstruments = order.getPaymentInstruments();

    if (paymentInstruments.length != 0) {
        return {
            missingPaymentInfo : true
        };
    }

    for (var i = 0; i < paymentInstruments.length; i++) {
        var PaymentInstrument = paymentInstruments[i];

        if (PaymentMgr.getPaymentMethod(PaymentInstrument.paymentMethod).paymentProcessor === null) {

            Transaction.wrap(function () {
                PaymentInstrument.getPaymentTransaction.setTransactionID(order.getOrderNo());
            });
        }
        else {
            /*
             * An Authorization Pipeline is being dynamically called based on a
             * concatenation of the current Payment-Processor and a constant
             * suffix (-Authorize). For example: Credit Cards processor ID =
             * BASIC_CREDIT Authorization Pipeline = BASIC_CREDIT-Authorize
             *
             * The authorization pipeline must end in a named "error" end node
             * to communicate any authorization error back to this pipeline.
             * Additionally the authorization pipeline may put a
             * dw.system.Status object into the pipeline dictionary under key
             * PlaceOrderError, which contains provider specific error messages.
             */
            var AuthorizationPipeline = PaymentMgr.getPaymentMethod(PaymentInstrument.paymentMethod).paymentProcessor.ID;

            // dynamic call node to authorization pipeline
            // TODO support global lookup of controller from site cartridge list
            var PaymentProcessor = require('./lib/payment/' + AuthorizationPipeline);
            var AuthorizationResult = PaymentProcessor.Authorize();

            if (AuthorizationResult.not_supported || AuthorizationResult.error) {
                return {
                    error : true
                };
            }
        }
    }

    return {};
}

/**
 * The entry point for the order creation. The start node needs to be private
 * since it is supposed to be called by pipelines only.
 */
function start() {
    var cart = Cart.get();
    if (!cart.object) {
        require('./Cart').Show();
        return {};
    }
    else {

        // Clean shipments.
        require('./COShipping').PrepareShipments(cart);

        // Make sure there are valid shipping address, accounting for gift certificate that would not have one.
        if (cart.getProductLineItems().size() > 0 && cart.getDefaultShipment().getShippingAddress() == null) {
            require('./COShipping').Start();
            return {};
        }

        // Make sure, the billing step has been fulfilled, otherwise restart checkout.
        if (!session.forms.billing.fulfilled.value) {
            require('./COCustomer').Start();
            return {};
        }

        Transaction.wrap(function () {
            cart.calculate();
        });

        if (!require('./COBilling').ValidatePayment(cart)) {
            require('./COBilling').Start();
            return {};
        }

        var validationResult = cart.validateForCheckout();

        // TODO - what are those used for - do they need to be returned/passed to a template ?
        var BasketStatus = validationResult.BasketStatus;
        var EnableCheckout = validationResult.EnableCheckout;

        // Recalculate the payments. If there is only gift certificates, make sure it covers the order total, if not
        // back to billing page.
        if (!cart.calculatePaymentTransactionTotal()) {
            require('./COBilling').Start();
            return {};
        }

        // Handle used addresses and credit cards.
	    var saveCCResult = require('./COBilling').SaveCreditCard();

        if (!saveCCResult) {
            return {
                error           : true,
                PlaceOrderError : new dw.system.Status(dw.system.Status.ERROR, "confirm.error.technical")
            };
        }

        // Creates a new order. This will internally ReserveInventoryForOrder and will create a new Order with status
        // 'Created'.
        var createOrderResult = createOrder(cart);
        if (createOrderResult.error) {
            var BasketStatus = new dw.system.Status(dw.system.Status.ERROR);
            require('./Cart').Show();
            return {};
        }
        var order = createOrderResult.Order;

        var handlePaymentsResult = handlePayments(order);
        if (handlePaymentsResult.error) {
	        OrderMgr.failOrder(order);
	        return {error : true};

        }
        else if (handlePaymentsResult.missingPaymentInfo) {
	        OrderMgr.failOrder(order);
	        return {error : true};
        }

        return submitImpl(order);
    }
}

function submitImpl(order) {

	var orderPlacementStatus = Transaction.wrap(function () {
		if (OrderMgr.placeOrder(order) === Status.ERROR) {
			OrderMgr.failOrder(order);
			return false;
		}

		order.setConfirmationStatus(order.CONFIRMATION_STATUS_CONFIRMED);

		return true;
	});

	if (orderPlacementStatus === Status.ERROR) {
	    return {error : true};
    }

    // Creates purchased gift certificates with this order.
    if (!createGiftCertificates(order)) {
	    OrderMgr.failOrder(order);
	    return {error : true};
    }

    // Send order confirmation and clear used forms within the checkout process.
    var template = new Template('mail/orderconfirmation');
    var mail = new Mail();

    mail.addTo(order.getCustomerEmail());
    mail.setFrom(dw.system.Site.getCurrent().getCustomPreferenceValue('customerServiceEmail'));
    mail.setSubject((dw.web.Resource.msg('order.orderconfirmation-email.001', 'order', null) + " " + order.getOrderNo()).toString());
    mail.setContent(template.render());

    mail.send();

    // Mark order as EXPORT_STATUS_READY.
    order.setExportStatus(dw.order.Order.EXPORT_STATUS_READY);
    order.setConfirmationStatus(dw.order.Order.CONFIRMATION_STATUS_CONFIRMED);

    clearForms();

    return {
        Order         : order,
        order_created : true
    };
}

/**
 * Responsible for creating the order, set the order status to 'Created'
 */
function createOrder(cart) {

    var CreateOrder2Result = new dw.system.Pipelet('CreateOrder2', {
        CreateCustomerNo : true
    }).execute({
            Basket : cart.object
        });
    if (CreateOrder2Result.result === PIPELET_ERROR) {
        return {
            error : true
        };
    }

    return {
        Order : CreateOrder2Result.Order
    };
}

/**
 * Clears all forms used in the checkout process.
 */
function clearForms() {
    session.forms.singleshipping.clearFormElement();
    session.forms.multishipping.clearFormElement();
    session.forms.billing.clearFormElement();
}

/*
 * These pipelines contain past order creation logic. However, they must be
 * called within the transaction.
 */

/**
 * Creates a gift certificate for each gift certificate line item in the order
 * and sends an email to the gift certificate receiver.
 */
function createGiftCertificates(order) {

    for (var i = 0; i < order.getGiftCertificateLineItems().length; i++) {
        var giftCertificateLineItem = order.getGiftCertificateLineItems()[i];

        var CreateGiftCertificateResult = new dw.system.Pipelet('CreateGiftCertificate').execute({
            Amount                  : giftCertificateLineItem.netPrice.value,
            RecipientEmail          : giftCertificateLineItem.recipientEmail,
            RecipientName           : giftCertificateLineItem.recipientName,
            SenderName              : giftCertificateLineItem.senderName,
            GiftCertificateLineItem : giftCertificateLineItem,
            Message                 : giftCertificateLineItem.message,
            OrderNo                 : order.getOrderNo()
        });
        if (CreateGiftCertificateResult.result === PIPELET_ERROR) {
            return false;
        }
        var giftCertificate = CreateGiftCertificateResult.GiftCertificate;

        var template = new Template('mail/giftcert');
        var mail = new Mail();

        mail.addTo(giftCertificate.recipientEmail);
        mail.setFrom(dw.system.Site.getCurrent().getCustomPreferenceValue('customerServiceEmail'));
        mail.setSubject(dw.web.Resource.msg('email.ordergcemsg', 'email', null) + " " + giftCertificate.senderName);
        mail.setContent(template.render());

        mail.send();
    }

    return true;
}

/**
 * Asynchronous Callbacks for OCAPI. These functions result in a JSON response.
 */
function submitPaymentJSON() {

	var order = Order.get(request.httpParameterMap.order_id.stringValue);
	if (!order.object || (request.httpParameterMap.order_token.stringValue != order.getOrderToken())) {
		view.get().render('checkout/components/faults');
		return;
	}

    if (!order) {
        view.get().render('checkout/components/faults');
        return;
    }
    else {
        var copyPaymentInfoResult = copyPaymentInfo();
        if (copyPaymentInfoResult.error) {
            view.get().render('checkout/components/faults');
            return;
        }

        var handlePaymentsResult = handlePayments();
        if (handlePaymentsResult.error) {
            view.get().render('checkout/components/faults');
            return;
        }

        view.get({}).render('checkout/components/payment_methods_success');

    }
}

function copyPaymentInfo() {
    session.forms.billing.paymentMethods.clearFormElement();

    new dw.system.Pipelet('Script', {
        Transactional : false,
        OnError       : 'PIPELET_ERROR',
        ScriptFile    : 'checkout/CopyPaymentMethodsFromOCAPIRequest.ds'
    }).execute({
            PaymentMethodsForm : session.forms.billing.paymentMethods,
            HttpParamMap       : request.httpParameterMap
        });

    // Order?
    var HandlePaymentSelectionResult = require('./COBilling').HandlePaymentSelection(cart);
    if (HandlePaymentSelectionResult.error) {
        return {
            error : true
        };
    }

    return {};
}

/*
 * Asynchronous Callbacks for SiteGenesis
 */
function submit() {

	var order = Order.get(request.httpParameterMap.order_id.stringValue);
	if (!order.object || (request.httpParameterMap.order_token.stringValue != order.getOrderToken())) {
        require('./COSummary').Start();
        return;
    }
    else if (submitImpl().error) {
        require('./COSummary').Start();
        return;
    }

    require('./COSummary').ShowConfirmation();
}

/**
 * Order successfully created, communicate status back to calling pipeline.
 * TODO ????
 */
/*
 * Module exports
 */

/*
 * Web exposed methods
 */
/** @see module:controller/COPlaceOrder~submitPaymentJSON */
exports.SubmitPaymentJSON = guard.ensure(['https'], submitPaymentJSON);
/** @see module:controller/COPlaceOrder~submitPaymentJSON */
exports.Submit = guard.ensure(['https'], submit);

/*
 * Local methods
 */
exports.Start = start;
