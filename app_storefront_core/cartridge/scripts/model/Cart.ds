'use strict';
/**
 * Module for cart related functionality.
 *
 * @module model/Cart
 */

/* API Includes */
var AbstractModel = require('./AbstractModel');
var ArrayList = require('dw/util/ArrayList');
var HashMap = require('dw/util/HashMap');
var Money = require('dw/value/Money');
var PaymentInstrument = require('dw/order/PaymentInstrument');
var Product = require('~/cartridge/scripts/model/Product');
var ProductInventoryMgr = require('dw/catalog/ProductInventoryMgr');
var PromotionMgr = require('dw/campaign/PromotionMgr');
var ShippingMgr = require('dw/order/ShippingMgr');
var StoreMgr = require('dw/catalog/StoreMgr');
var StringUtils = require('dw/util/StringUtils');
var TransientAddress = require('~/cartridge/scripts/model/TransientAddress');
var UUIDUtils = require('dw/util/UUIDUtils');

/**
 * Category helper providing enhanced category functionality
 * @class module:model/Cart~Cart
 */
var Cart = AbstractModel.extend(
    /** @lends module:model/Cart~Cart.prototype */
    {
        /**
         * Use this method to get a new instance for the current or a given basket.
         *
         * @param parameter
         * @returns {Cart}
         */
        get : function (parameter) {
            var obj = null;

            if (!parameter) {
                // TODO
                var GetBasketResult = new dw.system.Pipelet('GetBasket', {
                    Create : false
                }).execute();

                if (GetBasketResult.result !== PIPELET_ERROR) {
                    obj = GetBasketResult.Basket;
                }
            }
            else if (typeof parameter === 'object') {
                obj = parameter;
            }
            return new Cart(obj);
        },

        /**
         * Use this method to get or create a new instance of a basket
         c
         */
        goc : function () {
            var obj = null;

            var GetBasketResult = new dw.system.Pipelet('GetBasket', {
                Create : true
            }).execute();

            if (GetBasketResult.result !== PIPELET_ERROR) {
                obj = GetBasketResult.Basket;
            }

            return new Cart(obj);

        },

        /**
         * TODO
         */
        calculate : function () {

            dw.system.HookMgr.callHook("dw.ocapi.shop.basket.calculate", "calculate", this.object);

        },

        /**
         * TODO
         *
         * @param plid
         * @param itemid
         * @param quantity
         * @param cgid
         * @returns {null}
         */
        addProductListItem : function (productListItem, quantity, cgid) {

            if (productListItem) {

                var productOptionSelections = require('~/cartridge/scripts/util/ProductOptionSelection').getProductOptionSelections(productListItem.getProduct(), request.httpParameterMap);

                // TODO
                var AddProductToBasketResult = new dw.system.Pipelet('AddProductToBasket').execute({
                    Basket             : this.object,
                    ProductOptionModel : productOptionSelections.ProductOptionModel,
                    Quantity           : quantity,
                    Category           : dw.catalog.CatalogMgr.getCategory(cgid),
                    ProductListItem    : productListItem
                });
                if (AddProductToBasketResult.result === PIPELET_ERROR) {
                    return null;
                }

                this.calculate();
            }

            return;
        },

        /**
         * TODO
         *
         * @param pid
         * @param quantity
         * @param cgid
         */
        addProductItem : function (product, quantity, cgid, productOptionModel) {

            if (product) {

	            // TODO
                var AddProductToBasketResult = new dw.system.Pipelet('AddProductToBasket').execute({
                    Basket             : this.object,
                    Product            : product,
                    ProductOptionModel : productOptionModel,
                    Quantity           : quantity,
                    Category           : dw.catalog.CatalogMgr.getCategory(cgid)
                });

                if (AddProductToBasketResult.result === PIPELET_ERROR) {
                    return;
                }
                var ProductLineItem = AddProductToBasketResult.ProductLineItem;

                if (product.bundle) {
                    /**
                     * By default, when a bundle is added to cart all its sub products gets added too, but if those products happens to be
                     * variants then we have to manually replace the master products with the selected variants which gets passed in the
                     * http params as childPids along with any options. Params: CurrentHttpParameterMap.childPids - comma separated list of
                     * pids of the bundled products which are variations
                     */
                    if (request.httpParameterMap.childPids.stringValue) {
                        var childPids = request.httpParameterMap.childPids.stringValue.split(",");

                        for (var i = 0; i < childPids.length; i++) {
                            var childProduct = Product.get(childPids[i]).object;

                            if (childProduct) {
                                // why is this needed ?
                                require('~/cartridge/scripts/util/ProductOptionSelection').getProductOptionSelections(childProduct, request.httpParameterMap);

                                var foundLineItem = null;
                                foundLineItem = this.getBundledProductLineItemByPID(lineItem, (childProduct.isVariant() ? childProduct.masterProduct.ID : childProduct.ID));

                                if (foundLineItem) {
                                    foundLineItem.replaceProduct(childProduct);
                                }
                            }
                        }
                    }
                }

                this.calculate();

            }

            return;
        },

        /**
         *
         * @param couponCode
         * @returns {{CouponStatus: (Status|*|deleteAddress.Status|pdict.Status)}}
         */
        addCoupon : function (couponCode) {
            if (couponCode) {

                var AddCouponToBasket2Result = new dw.system.Pipelet('AddCouponToBasket2').execute({
                    Basket     : this.object,
                    CouponCode : couponCode
                });

                if (AddCouponToBasket2Result.result !== PIPELET_ERROR) {
                    this.calculate();
                    return {'CouponStatus' : AddCouponToBasket2Result.Status};
                }
            }

            return;
        },

        /**
         * Adds a bonus product to the Basket associated with the specified BonusDiscountLineItem. The pipelet creates
         * and returns a ProductLineItem, by assigning the specified Product and Quantity to the specified Basket. The
         * function adds the new ProductLineItem to the default shipment.
         * The passed product must be one of the products associated with the BonusDiscountLineItem or the process will
         * fail. The process does NOT validate if the number of bonus products exceeds the maximum allowed by the bonus
         * discount. This is the job of application logic.
         * Function always creates a new product line item, regardless of the value of the site preference
         * 'Add Product Behavior'.
         *
         * @param bonusDiscountLineItem
         * @param product
         */
        addBonusProduct : function (bonusDiscountLineItem, product, selectedOptions, quantity) {

            var ScriptResult = new dw.system.Pipelet('Script', {
                Transactional : false,
                OnError       : 'PIPELET_ERROR',
                ScriptFile    : 'cart/UpdateProductOptionSelections.ds'
            }).execute({
                    SelectedOptions : selectedOptions,
                    Product         : product
                });

            var AddBonusProductToBasketResult = new dw.system.Pipelet('AddBonusProductToBasket').execute({
                Basket                : this.object,
                BonusDiscountLineItem : bonusDiscountLineItem,
                Product               : product,
                Quantity              : quantity,
                ProductOptionModel    : ScriptResult.ProductOptionModel
            });

            if (AddBonusProductToBasketResult.result !== PIPELET_ERROR) {
                return AddBonusProductToBasketResult.ProductLineItem;
            }

            return null;
        },

        /**
         *
         * @param giftCertificateLineItem
         */
        removeGiftCertificateLineItem : function (giftCertificateLineItem) {

            // TODO - add check whether the given lineitem actually belongs to this cart object
            new dw.system.Pipelet('RemoveGiftCertificateLineItem').execute({
                GiftCertificateLineItem : giftCertificateLineItem
            });

            return;
        },

        /**
         * Deletes all the products associated with a bonus discount line item.
         *
         * @param bonusDiscountLineItem
         */
        removeBonusDiscountLineItemProducts : function (bonusDiscountLineItem) {
            // TODO - add check whether the given lineitem actually belongs to this cart object
            var plis = bonusDiscountLineItem.getBonusProductLineItems();

            for (var i = 0; i < plis.length; i++) {
                var pli = plis[i];
                if (pli.product != null) {
                    this.removeProductLineItem(pli);
                }
            }
        },

        /**
         *
         * @param lineItemUUID
         * @returns {*}
         */
        getProductLineItemByUUID : function (lineItemUUID) {
            var plis = this.getProductLineItems();
            var lineItem = null;

            for (var i = 0, il = plis.length; i < il; i++) {
                var item = plis[i];
                if ((lineItemUUID != null && item.UUID === lineItemUUID)) {
                    lineItem = item;
                    break;
                }
            }

            return lineItem;
        },

        /**
         *
         * @param bundleLineItem
         * @param pid
         * @returns {*}
         */
        getBundledProductLineItemByPID : function (bundleLineItem, pid) {
            // TODO - add check whether the given lineitem actually belongs to this cart object
            var plis = bundleLineItem.getBundledProductLineItems();
            var lineItem = null;

            for (var i = 0, il = plis.length; i < il; i++) {
                var item = plis[i];
                if ((pid != null && item.productID === pid)) {
                    lineItem = item;
                    break;
                }
            }

            return lineItem;
        },

        /**
         *
         * @param lineItemUUID
         * @returns {*}
         */
        getBonusDiscountLineItemByUUID : function (lineItemUUID) {
            var plis = this.getBonusDiscountLineItems();
            var lineItem = null;

            for (var i = 0, il = plis.length; i < il; i++) {
                var item = plis[i];
                if ((lineItemUUID != null && item.UUID === lineItemUUID)) {
                    lineItem = item;
                    break;
                }
            }

            return lineItem;
        },

        /**
         * This function will checks the instore qty against the store inventory in the case that the pli's qtyt has
         * been updated.
         */
        checkInStoreProducts : function () {
            if (dw.system.Site.getCurrent().getCustomPreferenceValue('enableStorePickUp')) {

                var allProductLineItems = this.getAllProductLineItems();
                for (var i = 0; i < allProductLineItems.length; i++) {
                    var pli = allProductLineItems[i];

                    //skip none instore pli's
                    if (pli.custom.fromStoreId) {
                        //check the qty against the inventory of the store with matching storeID,
                        //in the event that the cart is being updated with a new qty
                        var store = StoreMgr.getStore(pli.custom.fromStoreId);
                        var storeinventory = ProductInventoryMgr.getInventoryList(store.custom.inventoryListId);

                        if (storeinventory.getRecord(pli.productID).ATS.value >= pli.quantityValue) {
                            pli.custom.fromStoreId = store.ID;
                            pli.setProductInventoryList(storeinventory);

                        }
                        else {
                            //the in store line item will be reset to a regular home delivery item.
                            pli.custom.fromStoreId = "";
                            pli.setProductInventoryList(null);
                            pli.setShipment(this.getDefaultShipment());
                        }
                    }
                }
            }

            return;
        },

        /**
         * TODO
         *
         * @param previousBonusDiscountLineItems
         * @returns {*}
         */
        getNewBonusDiscountLineItem : function (previousBonusDiscountLineItems) {
            if (previousBonusDiscountLineItems) {
                var newBonusDiscountLineItems = this.getBonusDiscountLineItems();
                newBonusDiscountLineItems.removeAll(previousBonusDiscountLineItems);

                if (!newBonusDiscountLineItems.isEmpty()) {
                    return newBonusDiscountLineItems[i];
                }
            }

            return;
        },

        updateLineItem : function (lineItem, product, productOptionModel) {

            new dw.system.Pipelet('ReplaceLineItemProduct').execute({
                ProductLineItem    : lineItem,
                NewProduct         : product,
                Quantity           : request.httpParameterMap.Quantity.doubleValue,
                ProductOptionModel : productOptionModel
            });

            if (product.isBundle()) {

                /**
                 * By default, when a bundle is added to cart all its sub products gets added too, but if those products happens to be
                 * variants then we have to manually replace the master products with the selected variants which gets passed in the
                 * http params as childPids along with any options. Params: CurrentHttpParameterMap.childPids - comma separated list of
                 * pids of the bundled products which are variations
                 */
                if (request.httpParameterMap.childPids.stringValue) {
                    var childPids = request.httpParameterMap.childPids.stringValue.split(",");

                    for (var i = 0; i < childPids.length; i++) {
                        var childProduct = Product.get(childPids[i]).object;

                        if (childProduct) {
                            // why is this needed ?
                            require('~/cartridge/scripts/util/ProductOptionSelection').getProductOptionSelections(childProduct, request.httpParameterMap);

                            var foundLineItem = null;
                            foundLineItem = this.getBundledProductLineItemByPID(lineItem, (childProduct.isVariant() ? childProduct.masterProduct.ID : childProduct.ID));

                            if (foundLineItem) {
                                new dw.system.Pipelet('ReplaceLineItemProduct').execute({
                                    ProductLineItem : foundLineItem,
                                    NewProduct      : childProduct
                                });
                            }
                        }
                    }
                }
            }
        },

        /**
         *
         * @returns {*}
         */
        validateForCheckout : function () {

            var result = new dw.system.Pipelet('Script', {
                ScriptFile    : 'cart/ValidateCartForCheckout.ds',
                Transactional : false
            }).execute({
                    Basket      : this.object,
                    ValidateTax : false
                });

            return result;

        },

	    /**
	     * The function removes all empty shipments of the current cart.
	     */
	    removeEmptyShipments : function () {
            // get the list of shipments
            var shipments = this.getShipments();

            for (var i = 0; i < shipments.length; i++) {
                var shipment = shipments[i];

                if (!shipment.isDefault()) {
                    if (shipment.getProductLineItems().isEmpty() && shipment.getGiftCertificateLineItems().isEmpty()) {
                        this.removeShipment(shipment);
                    }
                }

            }
        },

	    /**
	     * Determines the physical shipments of the current cart. Physical shipments are shipments which contain at
	     * least one product line item. A shipment which contains only gift certificates is not a physical shipment.
	     *
	     * @returns {*}
	     */
        getPhysicalShipments : function () {

            // list of physical shipments
            var physicalShipments = new ArrayList();

            // find physical shipments
            var shipments = this.getShipments();

            for (var i = 0; i < shipments.length; i++) {
                var shipment = shipments[i];
                if (!shipment.getProductLineItems().isEmpty() && shipment.custom.shipmentType != 'instore') {
                    physicalShipments.add(shipment);
                }
            }

            return physicalShipments;
        },

	    /**
	     * Cleans the shipments of the current basket by putting all gift certificate line items to single, possibly
	     * new shipments (one shipment per gift certificate line item).
	     */
 	    updateGiftCertificateShipments : function () {

		    // list of line items
		    var giftCertificatesLI = new ArrayList();

		    // find gift certificates in shipments which have
		    // product line items and gift certificate line items merged
		    var shipments = this.getShipments();

		    for (var i = 0; i < shipments.length; i++) {
			    var shipment = shipments[i];

			    // skip shipment if no gift certificates are contained
			    if (shipment.giftCertificateLineItems.size() == 0) {
				    continue;
			    }

			    // skip shipment if no products and just one gift certificate is contained
			    if (shipment.productLineItems.size() == 0 && shipment.giftCertificateLineItems.size() == 1) {
				    continue;
			    }

			    // if there are gift certificates add them to the list
			    if (shipment.giftCertificateLineItems.size() > 0) {
				    giftCertificatesLI.addAll(shipment.giftCertificateLineItems);
			    }
		    }

		    // create a shipment for each gift certificate line item
		    for (var i = 0; i < giftCertificatesLI.length; i++) {
			    var newShipmentID = this.determineUniqueShipmentID("Shipment #");
			    giftCertificatesLI[i].setShipment(this.createShipment(newShipmentID));
		    }
	    },

	    /**
	     * Determines a unique shipment ID for shipments in the curent cart and the given base ID. The function appends
	     * a counter to the base ID and checks the existence of the resulting ID. If the resulting ID is unique this ID
	     * is returned, if not the counter is incremented and checked again.
	     *
	     * @param baseID
	     * @returns {*}
	     */
	    determineUniqueShipmentID : function (baseID) {
		    var counter = 1;
		    var shipment = null;
		    var candidateID = baseID + "" + counter;

		    while (shipment == null) {
			    shipment = this.getShipment(candidateID);
			    if (shipment != null) {
				    // this ID is already taken, increment the counter
				    // and try the next one
				    counter++;
				    candidateID = baseID + "" + counter;
				    shipment = null;
			    }
			    else {
				    return candidateID;
			    }
		    }

		    // should never go here
		    return null;
	    },

	    /**
	     * Creates a shipping address for the shipment with the given shipment ID.
	     *
	     * @param shipmentID
	     * @returns {*}
	     */
        createShipmentShippingAddress : function (shipmentID) {

            var shipment = this.getShipment(shipmentID);
            var shippingAddress = shipment.getShippingAddress();

            // if the shipment has no shipping address yet, create one
            if (shippingAddress === null) {
                shippingAddress = shipment.createShippingAddress();
            }

            return shippingAddress;

        },

	    /**
         * This script scans the basket and consildates items that are going to the same store, it also creates shipmets
         * with shipment type and method for the rest of checkout.
         *
         * @returns {boolean} Boolean used to show the shipping form fields if there is a home delivery found in the basket.
         */
        consolidateInStoreShipments : function () {

            var sliArrayList = new ArrayList();
            var homeDeliveries = false;

            var plis = this.getAllProductLineItems();
            for (var i = 0; i < plis.length; i++) {
                var pli = plis[i];

                if (pli.custom.fromStoreId == null) {
                    //skip none instore pli's
                    homeDeliveries = true;
                    continue;
                }
                if (pli.shipment.shippingMethod && pli.shipment.shippingMethod.custom.storePickupEnabled) {
                    //check to see if the storeid has changed
                    if (pli.custom.fromStoreId == pli.shipment.custom.fromStoreId) {
                        if (pli.shipment.shippingAddress != null) {
                            continue;
                        }
                        else {
                            //create the shipment address to reflect the new store address
                            var shippingAddress = new TransientAddress();
                            var storeObject = StoreMgr.getStore(pli.custom.fromStoreId);
                            var orderAddress = pli.shipment.createShippingAddress();
                            shippingAddress.storeAddressTo(orderAddress, storeObject);
                            continue;
                        }
                    }
                    else {
	                    var storeObject = StoreMgr.getStore(pli.custom.fromStoreId);
                        //change the shipment address to reflect the new store address
                        pli.shipment.shippingAddress.setFirstName('');
                        pli.shipment.shippingAddress.setLastName(storeObject.name);
                        pli.shipment.shippingAddress.setAddress1(storeObject.address1);
                        pli.shipment.shippingAddress.setAddress2(storeObject.address2);
                        pli.shipment.shippingAddress.setCity(storeObject.city);
                        pli.shipment.shippingAddress.setPostalCode(storeObject.postalCode);
                        pli.shipment.shippingAddress.setStateCode(storeObject.stateCode);
                        pli.shipment.shippingAddress.setCountryCode(storeObject.custom.countryCodeValue);
                        pli.shipment.shippingAddress.setPhone(storeObject.phone);
                        pli.shipment.custom.fromStoreId = pli.custom.fromStoreId;
                        continue;
                    }
                }

                //check to see if we are creating a new shipment or adding to an existing one
                if (sliArrayList.contains(pli.custom.fromStoreId)) {
                    //add the pli to the existing shipment
                    //loop through to find the shipment with the storeid and set it as the shipment for the pli
                    var shipments = this.getShipments();
                    for (var j = 0; j < this.getShipments().length; j++) {
                        var inStoreShipment = shipments[j];

                        if (inStoreShipment.custom.fromStoreId != null && (pli.custom.fromStoreId == inStoreShipment.custom.fromStoreId)) {
                            //have found an existing shipment that has the correct address
                            pli.setShipment(inStoreShipment);
                        }

                    }

                }
                else {
                    //create a new shipment to put this pli in
                    var shipment = null;
                    shipment = this.createShipment(UUIDUtils.createUUID());
                    shipment.custom.fromStoreId = pli.custom.fromStoreId;
                    shipment.custom.shipmentType = 'instore';

                    var inStoreShippingMethod = null;
                    //loop over the shipping methods and pick the instore one

                    var shippingMethods = new ArrayList(ShippingMgr.getShipmentShippingModel(shipment).getApplicableShippingMethods());
                    for (var k = 0; k < shippingMethods.length; k++) {
                        var shippingMethod = shippingMethods[k];

                        if (shippingMethod.custom.storePickupEnabled) {
                            shipment.setShippingMethod(shippingMethod);
                        }

                    }

                    var shippingAddress = new TransientAddress();
	                var storeObject = StoreMgr.getStore(pli.custom.fromStoreId);
                    var orderAddress = shipment.createShippingAddress();
                    shippingAddress.storeAddressTo(orderAddress, storeObject);
                    pli.setShipment(shipment);

                }

                sliArrayList.add(pli.custom.fromStoreId);
            }

            return homeDeliveries;
        },

	    /**
	     * This script updates the shipping method of the given shipment. If a shipping method ID is  given, the given shipping method used to update the shipment.
	     *
	     * @param shippingMethod
	     * @returns {{shippingExclDiscounts: *, shippingInclDiscounts: *, productShippingCosts: Array, productShippingDiscounts: ArrayList, shippingPriceAdjustments: Array, shippingPriceAdjustmentsTotal: Money, surchargeAdjusted: Money, baseShipping: *, baseShippingAdjusted: *}}
	     */
        preCalculateShipping : function (shippingMethod) {

            var shipment = this.getDefaultShipment();

	        if (shipment != null) {
                var currencyCode = this.getCurrencyCode();
                var discountPlan = PromotionMgr.getDiscounts(this.object),
                    productShippingCosts = [], // array to hold product level shipping costs (fixed or surcharges), each entry is an object containing product name and shipping cost
                    productShippingDiscounts = new ArrayList(), // list holds all products shipping discounts NOT promotions e.g. fixed shipping discount or free shipping for individual products discount
                    productIter = this.getAllProductLineItems().iterator(),
                    priceAdjArray = [], // array to hold shipping price adjustments data (we have to create objects since price adjustments get lost after applying a shipping method
                    priceAdjIter = shipment.getShippingPriceAdjustments().iterator(),
                    priceAdjTotal = new Money(0.0, currencyCode), // total of all price adjustments
                    surchargeTotal = new Money(0.0, currencyCode), // total of all surcharges
                    adustedSurchargeTotal = new Money(0.0, currencyCode); // total of all surcharges minus price adjustments

                // iterate over all products in the basket
                // and calculate their shipping cost and shipping discounts
                while (productIter.hasNext()) {
                    var pli = productIter.next();
                    var product = pli.product;
                    if (product != null) {
                        var psc = ShippingMgr.getProductShippingModel(product).getShippingCost(shippingMethod);
                        productShippingCosts[productShippingCosts.length] = {
                            "name"         : product.name,
                            "shippingCost" : psc,
                            "qty"          : pli.getQuantity()
                        };
						if (psc != null && psc.getAmount() != null && psc.isSurcharge()) {
                            // update the surcharge totals
                            surchargeTotal = surchargeTotal.add(psc.getAmount());
                            adustedSurchargeTotal = adustedSurchargeTotal.add(psc.getAmount());
                        }
                        //productShippingDiscounts.addAll(discountPlan.getProductShippingDiscounts(pli));
                        //productShippingDiscounts.addAll(pli.shippingLineItem.priceAdjustments);
                        if (pli.shippingLineItem != null) {
                            var pdiscountsiter = pli.shippingLineItem.priceAdjustments.iterator();
                            while (pdiscountsiter.hasNext()) {
                                var priceAdj = pdiscountsiter.next();
                                if (priceAdj != null && priceAdj.promotion !== null) {
                                    if (pli.shippingLineItem.isSurcharge()) {
                                        // adjust the surchage total value
                                        adustedSurchargeTotal = adustedSurchargeTotal.add(priceAdj.price);
                                    }
                                    productShippingDiscounts.add({
                                        "price"      : priceAdj.price,
                                        "calloutMsg" : priceAdj.promotion.calloutMsg
                                    });
                                }
                            }
                        }
                    }
                }

                // iterate over all shipping price adjustments and
                // grab price and calloutMsg objects
                while (priceAdjIter.hasNext()) {
                    var priceAdj = priceAdjIter.next();
                    if (priceAdj != null && priceAdj.promotion !== null) {
                        priceAdjTotal = priceAdjTotal.add(priceAdj.price);
                        priceAdjArray[priceAdjArray.length] = {
                            "price"      : priceAdj.price,
                            "calloutMsg" : priceAdj.promotion.calloutMsg
                        };
                    }
                }

                var baseShipping = this.getShippingTotalPrice().subtract(surchargeTotal);
                var baseShippingAdjusted = null;
                if (priceAdjTotal >= 0) {
                    baseShippingAdjusted = baseShipping.subtract(priceAdjTotal);
                }
                else {
                    baseShippingAdjusted = baseShipping.add(priceAdjTotal);
                }

                return {
                    "shippingExclDiscounts"         : this.getShippingTotalPrice(),
                    "shippingInclDiscounts"         : this.getAdjustedShippingTotalPrice(),
                    "productShippingCosts"          : productShippingCosts,
                    "productShippingDiscounts"      : productShippingDiscounts,
                    "shippingPriceAdjustments"      : priceAdjArray,
                    "shippingPriceAdjustmentsTotal" : priceAdjTotal,
                    "surchargeAdjusted"             : adustedSurchargeTotal,
                    "baseShipping"                  : baseShipping,
                    "baseShippingAdjusted"          : baseShippingAdjusted
                };
            }
	    },

        /**
         * This script sets the shipping method of the given shipment to the passed method.  The list of allowed shipping
         * methods may be passed in as a parameter.  If not, then it is retrieved using ShipmentShippingModel.getApplicableShippingMetods().
         * If the passed shipping method is not in this list, then the script uses the default shipping method.
         * If the default shipping method is not in the list, the script uses the first method in the list.
         *
         * @param shipmentID The ID of the shipment to update the shipping method for.
         * @param shippingMethodID The ID of the shipping method to set for the shipment.
         * @param shippingMethod The shipping method to set for the shipment.
         * @param shippingMethods The list of applicable shipping methods.
         */
        updateShipmentShippingMethod : function (shipmentID, shippingMethodID, shippingMethod, shippingMethods) {

            var shipment = this.getShipment(shipmentID);

            if (!shippingMethods) {
                shippingMethods = ShippingMgr.getShipmentShippingModel(shipment).getApplicableShippingMethods();
            }

            // 1) Try to set the shipment shipping method to the passed one.
            for (var i = 0; i < shippingMethods.length; i++) {
                var method = shippingMethods[i];

                if (!shippingMethod) {
                    if (!method.ID.equals(shippingMethodID)) {
                        continue;
                    }
                }
                else {
                    if (method != shippingMethod) {
                        continue;
                    }

                }

                // set this shipping method
                shipment.setShippingMethod(method);
                return;
            }

            var defaultShippingMethod = ShippingMgr.getDefaultShippingMethod();
            if (shippingMethods.contains(defaultShippingMethod)) {
                // 2) Set the default shipping method if it is applicable.
                shipment.setShippingMethod(defaultShippingMethod);
            }
            else if (shippingMethods.length > 0) {
                // 3) Set the first shipping method in the applicable list.
                shipment.setShippingMethod(shippingMethods.iterator().next());
            }
            else {
                // 4) Invalidate the current shipping method selection.
                shipment.setShippingMethod(null);
            }

            return;
        },

	    getApplicableShippingMethods : function (countryCode, stateCode, postalCode, city, address1, address2) {

		    // Construct an address from request parameters.
		    var addressObj = new Object();

		    // SiteGenesis-specific default used to define list of shipping methods shown by default.
		    // Modify as needed.
		    addressObj.countryCode = (countryCode === null || StringUtils.trim(countryCode) === "") ? "US" : StringUtils.trim(countryCode);
		    addressObj.stateCode = (stateCode === null || StringUtils.trim(stateCode) === "") ? "NY" : StringUtils.trim(stateCode);
		    addressObj.postalCode = postalCode && StringUtils.trim(postalCode);
		    addressObj.city = city && StringUtils.trim(city);
		    addressObj.address1 = address1 && StringUtils.trim(address1);
		    addressObj.address2 = address2 && StringUtils.trim(address2);

		    // Retrieve the list of applicabnle shipping methods for the given shipment and address.
		    return ShippingMgr.getShipmentShippingModel(this.getDefaultShipment()).getApplicableShippingMethods(addressObj);
	    },

	    /**
	     * Calculates the amount to be payed by a non-gift certificate payment instrument based on the given basket.
	     * The method subtracts the amount of all redeemed gift certificates from the order total and returns this
	     * value.
	     */
	    getNonGiftCertificateAmount : function () {
		    // the total redemption amount of all gift certificate payment instruments in the basket
		    var giftCertTotal = new Money(0.0, this.getCurrencyCode());

		    // get the list of all gift certificate payment instruments
		    var gcPaymentInstrs = this.getGiftCertificatePaymentInstruments();
		    var iter = gcPaymentInstrs.iterator();
		    var orderPI = null;

		    // sum the total redemption amount
		    while (iter.hasNext()) {
			    orderPI = iter.next();
			    giftCertTotal = giftCertTotal.add(orderPI.getPaymentTransaction().getAmount());
		    }

		    // get the order total
		    var orderTotal = this.getTotalGrossPrice();

		    // calculate the amount to charge for the payment instrument
		    // this is the remaining open order total which has to be paid
		    var amountOpen = orderTotal.subtract(giftCertTotal);

		    // return the open amount
		    return amountOpen;
	    },

	    /**
	     * Removes a gift certificate payment instrument with the given gift certificate ID
	     * from the basket.
	     */
	    removeGiftCertificatePaymentInstrument : function (giftCertificateID) {

		    // iterate over the list of payment instruments
		    var gcPaymentInstrs = this.getGiftCertificatePaymentInstruments(giftCertificateID);
		    var iter = gcPaymentInstrs.iterator();
		    var existingPI= null;

		    // remove (possible multiple) gift certificate payment
		    // instruments for this gift certificate ID
		    while (iter.hasNext()) {
			    existingPI = iter.next();
			    this.removePaymentInstrument(existingPI);
		    }

		    return;
	    },

	    /**
	     * Deletes multiple payment instruments.
	     *
	     * @param paymentInstruments
	     */
	    removePaymentInstruments : function (paymentInstruments) {

		    for (var i = 0; i < paymentInstruments.length; i++) {
			    var pi = paymentInstruments[i];
			    this.removePaymentInstrument(pi);
		    }

	    },

	    /**
	     * This script calculates the total amount of an order that will be paid for by gift certificate payment
	     * instruments. The remaining open amount (if there is any) will be applied to the non-gift certificate payment
	     * instrument (such as a credit card). Note, that this script assumes that only one non-gift certificate
	     * payment instrument is used for the payment.
	     */
	    calculatePaymentTransactionTotal : function () {

		    // get all payment instruments for the basket
            var iter = this.getPaymentInstruments().iterator();
            var paymentInstrument = null;
            var nonGCPaymentInstrument = null;
            var giftCertTotal = new Money(0.0, this.getCurrencyCode());

            // locate any non-gift certificate payment instrument
            while (iter.hasNext()) {
                paymentInstrument = iter.next();
                if (PaymentInstrument.METHOD_GIFT_CERTIFICATE.equals(paymentInstrument.getPaymentMethod())) {
                    giftCertTotal = giftCertTotal.add(paymentInstrument.getPaymentTransaction().getAmount());
                    continue;
                }

                // we captured the non-gift certificate payment instrument
                nonGCPaymentInstrument = paymentInstrument;
                break;
            }

            // get the order total
            var orderTotal = this.getTotalGrossPrice();

            // if we found gift certificate payment and non-gift certificate payment
            // instrument we are done
            if (!nonGCPaymentInstrument) {
                // if we have no other payment types and the gift certificate
                // doesn't cover the order we need to error out.
                if (giftCertTotal < orderTotal) {
                    return false;
                }
                else {
                    return true;
                }
            }

            // calculate the amount to be charged for the
            // non-gift certificate payment instrument
            var amount = this.getNonGiftCertificateAmount();

            // now set the non-gift certificate payment instrument total.
            if (amount.value <= 0.0) {
                var zero = new Money(0, amount.getCurrencyCode());
                nonGCPaymentInstrument.getPaymentTransaction().setAmount(zero);
            }
            else {
                nonGCPaymentInstrument.getPaymentTransaction().setAmount(amount);
            }

		    return true;
	    },

	    /**
	     * Creates a list of gift certificate ids from gift certificate payment instruments.
	     *
	     * @returns {dw.util.ArrayList}
	     */
        getGiftCertIdList : function () {
	        var gcIdList = new ArrayList();
	        var gcPIIter = this.getGiftCertificatePaymentInstruments.iterator();

	        while (gcPIIter.hasNext()) {
		        gcIdList.add((gcPIIter.next()).getGiftCertificateCode());
	        }

	        return gcIdList;
        },

	    /**
	     * This script creates new ProductLineItems and Shipments from the List of the address selections with help of
	     * a data structure (address and product relations through HashMaps).
	     *
	     * @param {dw.web.FormList} quantityLineItems
	     * @returns {*}
	     */
	    mergeQuantities : function (quantityLineItems) {

		    var addressRelations = new HashMap();
		    var defaultShippingSet = false;

		    /**
		     * Build new data structure through HashMaps from address-products-relations (stored in FormList)
		     * to build the new ProductLineItems in dependency to their addresses and quantities
		     *
		     * address relation:    +===============+=================+
             *                      |    Key        |    Value        |
             *                      +===============+=================+
             *                      |    address1   |    products1  --|------->    product relation 1:    +===============+===============+
             *                      +---------------+-----------------+                                   |    Key        |    Value      |
             *                      |    address2   |    products2  --|--->    product relation 2         +===============+===============+
             *                      +---------------+-----------------+                                   |   productID1  |   quantity1   |
             *                      |    ...        |    ...          |                                   +---------------+---------------+
             *                                                                                            |   productID2  |   quantity2   |
             *                                                                                            +---------------+---------------+
             *                                                                                            |    ...        |    ...        |
             */

		    for (var i = 0; i < quantityLineItems.getChildCount(); i++) {
			    var qli = quantityLineItems[i];
                var selectedAddress = qli.addressList.selectedOptionObject;
                var productID = qli.object.productID;

                var productOptionID = qli.object.optionID;
                productID = productID + '.' + productOptionID;

                if (selectedAddress == null) {
                    return false;
                }

                if (addressRelations.containsKey(selectedAddress)) {
                    var productRelations = addressRelations.get(selectedAddress);
                    if (productRelations.containsKey(productID)) {
                        var quantity = productRelations.get(productID);
                        productRelations.put(productID, quantity + 1);
                    }
                    else {
                        productRelations.put(productID, 1);
                    }
                }
                else {
                    var productRelations = new HashMap();
                    productRelations.put(productID, 1);
                    addressRelations.put(selectedAddress, productRelations);
                }
            }

            //Remove all ProductLineItems and Shipments to create new ones
		    var plis = this.getProductLineItems();
		    for (var i = 0; i < plis.length; i++) {
			    var pli = plis[i];
                if (empty(pli.custom.fromStoreId)) {
	                this.removeProductLineItem(pli);
                }
            }

		    var shipments = this.getShipments();
		    for (var i = 0; i < shipments.length; i++) {
			    var shipment = shipments[i];
                //if the shipment is for a gift certificate or the default shipment, it will not be removed from the cart
                if (!shipment.isDefault() && !(shipment.giftCertificateLineItems.length > 0) && shipment.custom.shipmentType !== 'instore') {
	                this.removeShipment(shipment);
                }
            }

            // Build new ProductLineItems and Shipments with the new created data structure
            var addresses = addressRelations.keySet();

		    for (var i = 0; i < addresses.length; i++) {
			    var address = addresses[i];
                var shipment = null;
                var orderAddress = null;
                if (!defaultShippingSet) {
                    shipment = this.getDefaultShipment();
                    defaultShippingSet = true;
                }
                else {
                    shipment = this.createShipment(address.UUID);
                }
                orderAddress = shipment.createShippingAddress();

			    var shippingAddress = new TransientAddress();
                shippingAddress.UUID = UUIDUtils.createUUID();
                shippingAddress.copyFrom(address);
                shippingAddress.copyTo(orderAddress);

                var productRelations = addressRelations.get(address);
                var products = productRelations.keySet();

                var product_ID = '';
                var optionID = '';

			    for (var j = 0; j < products.length; j++) {
				    var product = products[j];
                    var splitarray = product.split('.');
                    product_ID = splitarray[0];
                    optionID = splitarray[1];

                    var pli = this.createProductLineItem(product_ID, shipment);
                    pli.setQuantityValue(productRelations.get(product));

                    //re-assign the option product based on the optionID
                    if (optionID !== 'na') {
                        var productOptionModel = pli.product.getOptionModel();
                        var productOptions = productOptionModel.getOptions();
                        var pliOptionArrayList = new ArrayList(productOptions);
                        var productOption = pliOptionArrayList[0];

                        var options = productOptionModel.getOptionValues(productOption).iterator();
                        while (options.hasNext()) {

                            var optionValue = options.next();

                            // if the option id equals the selection option id, set the selected option
                            if (optionValue.getID() === optionID) {

                                var pliOptionProducts = new ArrayList(pli.optionProductLineItems);

	                            for (var k = 0; k < pliOptionProducts.length; k++) {
		                            pliOptionProducts[k].updateOptionValue(optionValue);
                                }
                            }
                        }
                    }
                }
            }

            return true;
        }

});

/** The cart class */
module.exports = new Cart();
